# 事件实现详细设计

## 1. 概述

本文档详细说明模拟"研建用管维"开发过程中每个事件的具体实现方式。由于这是一个**模拟系统**，所有事件都是按照预定流程触发的，用于演示真实的软件开发过程和效能指标计算。

### 1.1 模拟系统特点

**系统性质**：这是一个模拟软件开发过程的应用，具有以下特点：
- **模拟执行**：所有开发活动都是模拟的，不产生真实的产品
- **预定流程**：事件按照预定的时间序列和逻辑关系触发
- **模拟数据**：基于预设的算法和规则生成模拟数据
- **教学演示**：主要用于展示开发过程和效能度量

### 1.2 手动/自动模式实现

**手动模式**：
- 项目创建时手动配置团队规模、预算、时间等参数
- 每个阶段完成后手动点击"进入下一阶段"
- 可以手动调整模拟速度和参数

**自动模式**：
- 项目创建时选择预设模板（小型项目、中型项目、大型项目）
- 系统按照预设时间间隔自动推进各阶段
- 可以设置整体模拟速度（0.5x、1x、2x、3x）

**混合模式**：
- 项目创建时可以选择模板或手动配置
- 关键节点暂停等待用户确认
- 非关键环节自动推进

## 2. 研阶段事件详细实现

### 2.1 过程1: 项目启动与规划

#### 事件1: `PROJECT_INITIATED` - 项目启动
**触发机制**：用户操作触发（模拟系统）  
**实现设计**：
- **触发条件**：用户在模拟系统中点击"创建新项目"按钮
- **数据来源**：用户选择的项目模板或手动输入的配置参数
- **模拟特点**：这是模拟项目，不创建真实的开发项目
- **触发流程**：
  1. 用户选择项目模板（小型/中型/大型）或手动配置参数
  2. 系统根据配置生成模拟项目数据
  3. 创建模拟项目记录到数据库
  4. 生成`PROJECT_INITIATED`事件
  5. 初始化模拟项目状态为"规划中"
- **事件数据结构**：
```json
{
  "eventId": "PROJECT_INITIATED",
  "projectId": "proj_001",
  "timestamp": "2024-01-01T09:00:00Z",
  "triggeredBy": "admin_001",
  "data": {
    "projectName": "军用通信系统",
    "budget": 1000000,
    "estimatedDuration": 180,
    "teamSize": 10,
    "description": "新一代军用加密通信系统"
  }
}
```
- **前端实现**：
```typescript
// 前端项目创建组件
async createProject(formData: ProjectFormData): Promise<void> {
  try {
    const response = await this.projectApi.create(formData);
    this.$message.success('项目创建成功');
    this.$router.push(`/project/${response.data.id}`);
  } catch (error) {
    this.$message.error('项目创建失败');
  }
}
```
- **后端实现**：
```typescript
// 后端项目创建API
async createProject(projectData: CreateProjectDto): Promise<Project> {
  // 1. 验证用户权限
  await this.authService.validatePermission(userId, 'create_project');
  
  // 2. 创建项目
  const project = await this.projectRepository.create({
    ...projectData,
    status: ProjectStatus.PLANNING,
    createdBy: userId,
    createdAt: new Date()
  });
  
  // 3. 生成事件
  await this.eventService.publishEvent({
    eventId: 'PROJECT_INITIATED',
    projectId: project.id,
    timestamp: new Date(),
    triggeredBy: userId,
    data: projectData
  });
  
  return project;
}
```

#### 事件2: `WORK_ITEM_CREATED` - 工作项创建 (→指标3)
**触发机制**：用户操作触发  
**实现设计**：
- **触发条件**：项目经理在工作项管理界面创建新工作项
- **数据来源**：用户填写的工作项详细信息
- **触发流程**：
  1. 用户在前端填写工作项表单（标题、描述、类型、优先级）
  2. 前端发送创建工作项API请求
  3. 后端创建工作项记录
  4. 生成`WORK_ITEM_CREATED`事件
  5. 更新指标3相关数据
- **指标影响**：指标3工作项概览的工作项总数+1
- **事件数据结构**：
```json
{
  "eventId": "WORK_ITEM_CREATED",
  "projectId": "proj_001",
  "timestamp": "2024-01-01T10:30:00Z",
  "triggeredBy": "pm_001",
  "data": {
    "workItemId": "wi_001",
    "title": "需求分析任务",
    "type": "requirement",
    "priority": "high",
    "status": "created",
    "estimatedHours": 40,
    "description": "分析军用通信系统的功能需求"
  }
}
```
- **前端实现**：
```vue
<template>
  <el-dialog v-model="dialogVisible" title="创建工作项">
    <el-form :model="form" :rules="rules" ref="formRef">
      <el-form-item label="标题" prop="title">
        <el-input v-model="form.title" placeholder="请输入工作项标题" />
      </el-form-item>
      <el-form-item label="类型" prop="type">
        <el-select v-model="form.type">
          <el-option label="需求" value="requirement" />
          <el-option label="任务" value="task" />
          <el-option label="缺陷" value="bug" />
        </el-select>
      </el-form-item>
      <el-form-item label="优先级" prop="priority">
        <el-select v-model="form.priority">
          <el-option label="高" value="high" />
          <el-option label="中" value="medium" />
          <el-option label="低" value="low" />
        </el-select>
      </el-form-item>
      <el-form-item label="预估工时" prop="estimatedHours">
        <el-input-number v-model="form.estimatedHours" :min="1" />
      </el-form-item>
    </el-form>
    
    <template #footer>
      <el-button @click="dialogVisible = false">取消</el-button>
      <el-button type="primary" @click="createWorkItem">创建</el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
async function createWorkItem() {
  try {
    await workItemApi.create(props.projectId, form.value);
    ElMessage.success('工作项创建成功');
    dialogVisible.value = false;
    emit('created');
  } catch (error) {
    ElMessage.error('工作项创建失败');
  }
}
</script>
```
- **后端实现**：
```typescript
async createWorkItem(projectId: string, workItemData: CreateWorkItemDto): Promise<WorkItem> {
  // 1. 验证项目存在和权限
  const project = await this.projectRepository.findById(projectId);
  if (!project) throw new NotFoundException('项目不存在');
  
  // 2. 创建工作项
  const workItem = await this.workItemRepository.create({
    ...workItemData,
    projectId,
    status: WorkItemStatus.CREATED,
    createdBy: userId,
    createdAt: new Date()
  });
  
  // 3. 生成事件
  await this.eventService.publishEvent({
    eventId: 'WORK_ITEM_CREATED',
    projectId,
    timestamp: new Date(),
    triggeredBy: userId,
    data: {
      workItemId: workItem.id,
      ...workItemData
    }
  });
  
  return workItem;
}
```

#### 事件3: `REQUIREMENT_CREATED` - 需求创建 (→指标45)
**触发机制**：用户操作触发  
**实现设计**：
- **触发条件**：需求分析师创建新的需求条目
- **数据来源**：需求管理界面的用户输入
- **触发流程**：
  1. 需求分析师在需求管理界面点击"新建需求"
  2. 填写需求详细信息（标题、描述、优先级、来源等）
  3. 提交需求创建请求
  4. 系统生成唯一需求ID并保存
  5. 生成`REQUIREMENT_CREATED`事件
  6. 更新指标45新增需求趋势
- **指标影响**：指标45新增需求趋势的需求数量+1
- **事件数据结构**：
```json
{
  "eventId": "REQUIREMENT_CREATED",
  "projectId": "proj_001",
  "timestamp": "2024-01-02T10:30:00Z",
  "triggeredBy": "analyst_001",
  "data": {
    "requirementId": "req_001",
    "title": "实时语音通信功能",
    "description": "支持多方实时语音通信，延迟<100ms",
    "priority": "high",
    "source": "user_feedback",
    "category": "functional",
    "storyPoints": 13
  }
}
```
- **前端实现**：
```vue
<template>
  <div class="requirement-management">
    <el-button type="primary" @click="showCreateDialog">新建需求</el-button>
    
    <el-dialog v-model="createDialogVisible" title="新建需求" width="800px">
      <el-form :model="requirementForm" :rules="requirementRules" ref="formRef">
        <el-form-item label="需求标题" prop="title">
          <el-input v-model="requirementForm.title" placeholder="请输入需求标题" />
        </el-form-item>
        
        <el-form-item label="需求描述" prop="description">
          <el-input 
            v-model="requirementForm.description" 
            type="textarea" 
            :rows="4"
            placeholder="请详细描述需求内容"
          />
        </el-form-item>
        
        <el-form-item label="优先级" prop="priority">
          <el-radio-group v-model="requirementForm.priority">
            <el-radio label="high">高</el-radio>
            <el-radio label="medium">中</el-radio>
            <el-radio label="low">低</el-radio>
          </el-radio-group>
        </el-form-item>
        
        <el-form-item label="需求来源" prop="source">
          <el-select v-model="requirementForm.source">
            <el-option label="用户反馈" value="user_feedback" />
            <el-option label="市场调研" value="market_research" />
            <el-option label="技术改进" value="technical_improvement" />
            <el-option label="法规要求" value="regulatory_requirement" />
          </el-select>
        </el-form-item>
        
        <el-form-item label="需求类型" prop="category">
          <el-select v-model="requirementForm.category">
            <el-option label="功能性需求" value="functional" />
            <el-option label="非功能性需求" value="non_functional" />
            <el-option label="约束性需求" value="constraint" />
          </el-select>
        </el-form-item>
        
        <el-form-item label="故事点" prop="storyPoints">
          <el-select v-model="requirementForm.storyPoints">
            <el-option label="1" :value="1" />
            <el-option label="2" :value="2" />
            <el-option label="3" :value="3" />
            <el-option label="5" :value="5" />
            <el-option label="8" :value="8" />
            <el-option label="13" :value="13" />
            <el-option label="21" :value="21" />
          </el-select>
        </el-form-item>
      </el-form>
      
      <template #footer>
        <el-button @click="createDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="createRequirement">创建需求</el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue';
import { ElMessage } from 'element-plus';
import { requirementApi } from '@/api/requirement';

const createDialogVisible = ref(false);
const requirementForm = reactive({
  title: '',
  description: '',
  priority: 'medium',
  source: 'user_feedback',
  category: 'functional',
  storyPoints: 5
});

const requirementRules = {
  title: [{ required: true, message: '请输入需求标题', trigger: 'blur' }],
  description: [{ required: true, message: '请输入需求描述', trigger: 'blur' }]
};

async function createRequirement() {
  try {
    await requirementApi.create(props.projectId, requirementForm);
    ElMessage.success('需求创建成功');
    createDialogVisible.value = false;
    await refreshRequirements();
  } catch (error) {
    ElMessage.error('需求创建失败');
  }
}
</script>
```
- **后端实现**：
```typescript
@Controller('requirements')
export class RequirementController {
  constructor(
    private readonly requirementService: RequirementService,
    private readonly eventService: EventService
  ) {}

  @Post(':projectId')
  async createRequirement(
    @Param('projectId') projectId: string,
    @Body() createRequirementDto: CreateRequirementDto,
    @Request() req: any
  ): Promise<Requirement> {
    // 1. 验证项目存在
    const project = await this.projectService.findById(projectId);
    if (!project) {
      throw new NotFoundException('项目不存在');
    }

    // 2. 创建需求
    const requirement = await this.requirementService.create({
      ...createRequirementDto,
      projectId,
      status: RequirementStatus.DRAFT,
      createdBy: req.user.id,
      createdAt: new Date()
    });

    // 3. 生成事件
    await this.eventService.publishEvent({
      eventId: 'REQUIREMENT_CREATED',
      projectId,
      timestamp: new Date(),
      triggeredBy: req.user.id,
      data: {
        requirementId: requirement.id,
        title: requirement.title,
        description: requirement.description,
        priority: requirement.priority,
        source: requirement.source,
        category: requirement.category,
        storyPoints: requirement.storyPoints
      }
    });

    return requirement;
  }
}
```

## 3. 建阶段事件详细实现

### 3.1 过程7: 编码实现（核心过程）

#### 事件4: `CODE_COMMITTED` - 代码提交 (→指标20)
**触发机制**：模拟系统自动触发  
**实现设计**：
- **触发条件**：模拟系统按照预定时间间隔生成代码提交事件
- **数据来源**：基于项目配置和随机算法生成的模拟提交数据
- **模拟特点**：不连接真实Git系统，所有提交都是模拟的
- **触发流程**：
  1. 模拟系统根据团队配置和开发阶段计算提交频率
  2. 按照预设算法生成模拟的提交信息
  3. 生成`CODE_COMMITTED`事件
  4. 更新指标20代码提交趋势
- **指标影响**：指标20代码提交趋势的提交次数+1
- **事件数据结构**：
```json
{
  "eventId": "CODE_COMMITTED",
  "projectId": "proj_001",
  "timestamp": "2024-01-10T15:30:00Z",
  "triggeredBy": "dev_001",
  "data": {
    "commitId": "a1b2c3d4e5f6",
    "author": "dev_001",
    "authorEmail": "dev001@company.com",
    "message": "实现语音通信核心功能",
    "filesChanged": 5,
    "linesAdded": 234,
    "linesDeleted": 12,
    "branch": "feature/voice-communication",
    "repository": "military-comm-system"
  }
}
```
- **Git Hook实现**：
```bash
#!/bin/bash
# post-commit hook

# 获取提交信息
COMMIT_ID=$(git rev-parse HEAD)
AUTHOR=$(git log -1 --format='%an')
AUTHOR_EMAIL=$(git log -1 --format='%ae')
MESSAGE=$(git log -1 --format='%s')
TIMESTAMP=$(git log -1 --format='%ci')
BRANCH=$(git branch --show-current)

# 获取文件变更统计
STATS=$(git diff --stat HEAD~1 HEAD)
FILES_CHANGED=$(echo "$STATS" | wc -l)
LINES_ADDED=$(git diff --numstat HEAD~1 HEAD | awk '{sum+=$1} END {print sum}')
LINES_DELETED=$(git diff --numstat HEAD~1 HEAD | awk '{sum+=$2} END {print sum}')

# 调用后端API
curl -X POST "http://localhost:3000/api/events/git-commit" \
  -H "Content-Type: application/json" \
  -d "{
    \"commitId\": \"$COMMIT_ID\",
    \"author\": \"$AUTHOR\",
    \"authorEmail\": \"$AUTHOR_EMAIL\",
    \"message\": \"$MESSAGE\",
    \"timestamp\": \"$TIMESTAMP\",
    \"branch\": \"$BRANCH\",
    \"filesChanged\": $FILES_CHANGED,
    \"linesAdded\": $LINES_ADDED,
    \"linesDeleted\": $LINES_DELETED,
    \"repository\": \"$(basename $(git rev-parse --show-toplevel))\"
  }"
```
- **后端Git集成服务**：
```typescript
@Controller('events')
export class EventController {
  constructor(
    private readonly eventService: EventService,
    private readonly projectService: ProjectService
  ) {}

  @Post('git-commit')
  async handleGitCommit(@Body() gitCommitData: GitCommitData): Promise<void> {
    try {
      // 1. 根据仓库名称找到对应项目
      const project = await this.projectService.findByRepository(gitCommitData.repository);
      if (!project) {
        console.warn(`未找到仓库 ${gitCommitData.repository} 对应的项目`);
        return;
      }

      // 2. 验证提交者是否是项目成员
      const isMember = await this.projectService.isMember(project.id, gitCommitData.authorEmail);
      if (!isMember) {
        console.warn(`提交者 ${gitCommitData.authorEmail} 不是项目 ${project.id} 的成员`);
        return;
      }

      // 3. 生成代码提交事件
      await this.eventService.publishEvent({
        eventId: 'CODE_COMMITTED',
        projectId: project.id,
        timestamp: new Date(gitCommitData.timestamp),
        triggeredBy: gitCommitData.author,
        data: {
          commitId: gitCommitData.commitId,
          author: gitCommitData.author,
          authorEmail: gitCommitData.authorEmail,
          message: gitCommitData.message,
          filesChanged: gitCommitData.filesChanged,
          linesAdded: gitCommitData.linesAdded,
          linesDeleted: gitCommitData.linesDeleted,
          branch: gitCommitData.branch,
          repository: gitCommitData.repository
        }
      });

      console.log(`代码提交事件已生成: ${gitCommitData.commitId}`);
    } catch (error) {
      console.error('处理Git提交事件失败:', error);
    }
  }
}
```

#### 事件5: `BUILD_TASK_FAILED` - 构建任务失败 (→指标27)
**触发机制**：外部集成触发  
**实现设计**：
- **触发条件**：CI/CD流水线中的构建任务执行失败
- **数据来源**：CI/CD系统（如Jenkins、GitLab CI）的状态通知
- **触发流程**：
  1. CI/CD系统执行构建任务
  2. 构建失败时发送状态通知到系统
  3. 系统接收失败通知并解析错误信息
  4. 生成`BUILD_TASK_FAILED`事件
  5. 更新指标27失败率统计
- **指标影响**：指标27失败率按任务排名的失败次数+1
- **事件数据结构**：
```json
{
  "eventId": "BUILD_TASK_FAILED",
  "projectId": "proj_001",
  "timestamp": "2024-01-10T16:15:00Z",
  "triggeredBy": "ci_system",
  "data": {
    "buildId": "build_001",
    "taskName": "unit-test",
    "pipelineId": "pipeline_001",
    "failureReason": "test_failure",
    "errorMessage": "VoiceCommunicationTest.testLatency failed: Expected: <100 Actual: <150",
    "failedStep": "run-unit-tests",
    "duration": 45,
    "retryCount": 2,
    "branch": "feature/voice-communication",
    "commitId": "a1b2c3d4e5f6"
  }
}
```
- **Jenkins Pipeline实现**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                script {
                    try {
                        sh 'mvn clean compile'
                        // 构建成功通知
                        notifyBuildSuccess('build', env.BUILD_ID)
                    } catch (Exception e) {
                        // 构建失败通知
                        notifyBuildFailure('build', env.BUILD_ID, e.getMessage())
                        throw e
                    }
                }
            }
        }
        
        stage('Test') {
            steps {
                script {
                    try {
                        sh 'mvn test'
                        // 测试成功通知
                        notifyBuildSuccess('unit-test', env.BUILD_ID)
                    } catch (Exception e) {
                        // 测试失败通知
                        notifyBuildFailure('unit-test', env.BUILD_ID, e.getMessage())
                        throw e
                    }
                }
            }
        }
    }
}

def notifyBuildFailure(taskName, buildId, errorMessage) {
    def payload = [
        buildId: buildId,
        taskName: taskName,
        pipelineId: env.JOB_NAME,
        failureReason: 'build_failure',
        errorMessage: errorMessage,
        failedStep: env.STAGE_NAME,
        duration: currentBuild.duration / 1000,
        branch: env.BRANCH_NAME,
        commitId: env.GIT_COMMIT
    ]
    
    httpRequest(
        httpMode: 'POST',
        url: 'http://localhost:3000/api/events/build-failed',
        contentType: 'APPLICATION_JSON',
        requestBody: groovy.json.JsonBuilder(payload).toString()
    )
}
```
- **后端CI集成服务**：
```typescript
@Controller('events')
export class EventController {
  @Post('build-failed')
  async handleBuildFailure(@Body() buildFailureData: BuildFailureData): Promise<void> {
    try {
      // 1. 根据流水线ID找到对应项目
      const project = await this.projectService.findByPipelineId(buildFailureData.pipelineId);
      if (!project) {
        console.warn(`未找到流水线 ${buildFailureData.pipelineId} 对应的项目`);
        return;
      }

      // 2. 生成构建失败事件
      await this.eventService.publishEvent({
        eventId: 'BUILD_TASK_FAILED',
        projectId: project.id,
        timestamp: new Date(),
        triggeredBy: 'ci_system',
        data: {
          buildId: buildFailureData.buildId,
          taskName: buildFailureData.taskName,
          pipelineId: buildFailureData.pipelineId,
          failureReason: buildFailureData.failureReason,
          errorMessage: buildFailureData.errorMessage,
          failedStep: buildFailureData.failedStep,
          duration: buildFailureData.duration,
          retryCount: buildFailureData.retryCount || 0,
          branch: buildFailureData.branch,
          commitId: buildFailureData.commitId
        }
      });

      // 3. 发送通知给相关人员
      await this.notificationService.sendBuildFailureNotification(
        project.id,
        buildFailureData
      );

      console.log(`构建失败事件已生成: ${buildFailureData.buildId}`);
    } catch (error) {
      console.error('处理构建失败事件失败:', error);
    }
  }
}
```

## 4. 用阶段事件详细实现

### 4.1 过程10: 软件部署与发布

#### 事件6: `DEPLOYMENT_FAILED` - 部署失败 (→指标37)
**触发机制**：外部集成触发  
**实现设计**：
- **触发条件**：部署过程中发生错误导致失败
- **数据来源**：部署系统的错误状态报告
- **触发流程**：
  1. 部署系统检测到部署失败
  2. 记录失败时间和错误信息
  3. 生成`DEPLOYMENT_FAILED`事件
  4. 启动故障恢复流程
- **指标影响**：指标37流水线失败恢复分布的失败时间记录
- **事件数据结构**：
```json
{
  "eventId": "DEPLOYMENT_FAILED",
  "projectId": "proj_001",
  "timestamp": "2024-01-15T10:30:00Z",
  "triggeredBy": "deploy_system",
  "data": {
    "deploymentId": "deploy_001",
    "environment": "production",
    "version": "v1.2.0",
    "failureReason": "database_connection_error",
    "errorMessage": "Unable to connect to production database: Connection timeout after 30s",
    "failedStep": "database_migration",
    "rollbackInitiated": true,
    "affectedServices": ["user-service", "auth-service"],
    "estimatedRecoveryTime": 1800
  }
}
```
- **Kubernetes部署监控**：
```yaml
# deployment-monitor.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: deployment-monitor
data:
  monitor.sh: |
    #!/bin/bash
    
    # 监控部署状态
    DEPLOYMENT_NAME=$1
    NAMESPACE=$2
    PROJECT_ID=$3
    
    # 等待部署完成或失败
    kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=300s
    
    if [ $? -eq 0 ]; then
        # 部署成功
        curl -X POST "http://event-service:3000/api/events/deployment-success" \
          -H "Content-Type: application/json" \
          -d "{
            \"deploymentId\": \"$DEPLOYMENT_NAME-$(date +%s)\",
            \"projectId\": \"$PROJECT_ID\",
            \"environment\": \"$NAMESPACE\",
            \"version\": \"$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2)\"
          }"
    else
        # 部署失败
        ERROR_MSG=$(kubectl describe deployment $DEPLOYMENT_NAME -n $NAMESPACE | tail -10)
        
        curl -X POST "http://event-service:3000/api/events/deployment-failed" \
          -H "Content-Type: application/json" \
          -d "{
            \"deploymentId\": \"$DEPLOYMENT_NAME-$(date +%s)\",
            \"projectId\": \"$PROJECT_ID\",
            \"environment\": \"$NAMESPACE\",
            \"failureReason\": \"deployment_timeout\",
            \"errorMessage\": \"$ERROR_MSG\",
            \"failedStep\": \"pod_startup\"
          }"
    fi
```

## 5. 管阶段事件详细实现

### 5.1 过程14: 团队协作管理

#### 事件7: `TIME_LOG_RECORDED` - 工时记录 (→指标7)
**触发机制**：用户操作触发  
**实现设计**：
- **触发条件**：团队成员提交工时记录
- **数据来源**：工时记录表单的用户输入
- **触发流程**：
  1. 成员在工时记录界面选择日期和任务
  2. 输入实际工作时长和工作描述
  3. 提交工时记录
  4. 系统验证和保存工时数据
  5. 生成`TIME_LOG_RECORDED`事件
  6. 更新指标7工时排名统计
- **指标影响**：指标7工时排名的个人工时累计
- **事件数据结构**：
```json
{
  "eventId": "TIME_LOG_RECORDED",
  "projectId": "proj_001",
  "timestamp": "2024-01-10T18:00:00Z",
  "triggeredBy": "dev_001",
  "data": {
    "timeLogId": "tl_001",
    "memberId": "dev_001",
    "date": "2024-01-10",
    "hoursWorked": 8,
    "taskId": "task_005",
    "workDescription": "实现语音编码功能，完成单元测试",
    "workType": "development",
    "billable": true,
    "approvedBy": null,
    "status": "submitted"
  }
}
```
- **前端工时记录组件**：
```vue
<template>
  <div class="time-log-form">
    <el-card title="工时记录">
      <el-form :model="timeLogForm" :rules="rules" ref="formRef">
        <el-form-item label="日期" prop="date">
          <el-date-picker 
            v-model="timeLogForm.date" 
            type="date" 
            placeholder="选择日期"
            :disabled-date="disabledDate"
          />
        </el-form-item>
        
        <el-form-item label="关联任务" prop="taskId">
          <el-select v-model="timeLogForm.taskId" placeholder="选择任务">
            <el-option 
              v-for="task in availableTasks" 
              :key="task.id"
              :label="task.title" 
              :value="task.id"
            />
          </el-select>
        </el-form-item>
        
        <el-form-item label="工作时长" prop="hoursWorked">
          <el-input-number 
            v-model="timeLogForm.hoursWorked" 
            :min="0.5" 
            :max="12" 
            :step="0.5"
            placeholder="小时"
          />
        </el-form-item>
        
        <el-form-item label="工作类型" prop="workType">
          <el-select v-model="timeLogForm.workType">
            <el-option label="开发" value="development" />
            <el-option label="测试" value="testing" />
            <el-option label="设计" value="design" />
            <el-option label="会议" value="meeting" />
            <el-option label="文档" value="documentation" />
            <el-option label="其他" value="other" />
          </el-select>
        </el-form-item>
        
        <el-form-item label="工作描述" prop="workDescription">
          <el-input 
            v-model="timeLogForm.workDescription" 
            type="textarea" 
            :rows="3"
            placeholder="请描述今天的主要工作内容"
          />
        </el-form-item>
        
        <el-form-item label="是否计费">
          <el-switch v-model="timeLogForm.billable" />
        </el-form-item>
      </el-form>
      
      <div class="form-actions">
        <el-button @click="resetForm">重置</el-button>
        <el-button type="primary" @click="submitTimeLog">提交工时</el-button>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue';
import { ElMessage } from 'element-plus';
import { timeLogApi } from '@/api/timeLog';
import { taskApi } from '@/api/task';

const props = defineProps<{
  projectId: string;
}>();

const timeLogForm = reactive({
  date: new Date(),
  taskId: '',
  hoursWorked: 8,
  workType: 'development',
  workDescription: '',
  billable: true
});

const availableTasks = ref([]);

const rules = {
  date: [{ required: true, message: '请选择日期', trigger: 'change' }],
  taskId: [{ required: true, message: '请选择关联任务', trigger: 'change' }],
  hoursWorked: [{ required: true, message: '请输入工作时长', trigger: 'blur' }],
  workDescription: [{ required: true, message: '请描述工作内容', trigger: 'blur' }]
};

onMounted(async () => {
  await loadAvailableTasks();
});

async function loadAvailableTasks() {
  try {
    const response = await taskApi.getMyTasks(props.projectId);
    availableTasks.value = response.data;
  } catch (error) {
    ElMessage.error('加载任务列表失败');
  }
}

function disabledDate(date: Date) {
  // 不允许选择未来日期和30天前的日期
  const now = new Date();
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  return date > now || date < thirtyDaysAgo;
}

async function submitTimeLog() {
  try {
    const formRef = this.$refs.formRef;
    await formRef.validate();
    
    await timeLogApi.create(props.projectId, timeLogForm);
    ElMessage.success('工时记录提交成功');
    
    // 重置表单
    resetForm();
  } catch (error) {
    ElMessage.error('工时记录提交失败');
  }
}

function resetForm() {
  timeLogForm.date = new Date();
  timeLogForm.taskId = '';
  timeLogForm.hoursWorked = 8;
  timeLogForm.workType = 'development';
  timeLogForm.workDescription = '';
  timeLogForm.billable = true;
}
</script>
```
- **后端工时记录服务**：
```typescript
@Controller('time-logs')
export class TimeLogController {
  constructor(
    private readonly timeLogService: TimeLogService,
    private readonly eventService: EventService,
    private readonly taskService: TaskService
  ) {}

  @Post(':projectId')
  async createTimeLog(
    @Param('projectId') projectId: string,
    @Body() createTimeLogDto: CreateTimeLogDto,
    @Request() req: any
  ): Promise<TimeLog> {
    // 1. 验证任务存在且属于当前项目
    const task = await this.taskService.findById(createTimeLogDto.taskId);
    if (!task || task.projectId !== projectId) {
      throw new BadRequestException('任务不存在或不属于当前项目');
    }

    // 2. 验证日期不能是未来日期
    const logDate = new Date(createTimeLogDto.date);
    if (logDate > new Date()) {
      throw new BadRequestException('不能记录未来日期的工时');
    }

    // 3. 检查是否已有当天的工时记录
    const existingLog = await this.timeLogService.findByMemberAndDate(
      req.user.id, 
      projectId, 
      logDate
    );
    if (existingLog) {
      throw new ConflictException('当天已有工时记录，请修改现有记录');
    }

    // 4. 创建工时记录
    const timeLog = await this.timeLogService.create({
      ...createTimeLogDto,
      projectId,
      memberId: req.user.id,
      status: TimeLogStatus.SUBMITTED,
      createdAt: new Date()
    });

    // 5. 生成事件
    await this.eventService.publishEvent({
      eventId: 'TIME_LOG_RECORDED',
      projectId,
      timestamp: new Date(),
      triggeredBy: req.user.id,
      data: {
        timeLogId: timeLog.id,
        memberId: req.user.id,
        date: createTimeLogDto.date,
        hoursWorked: createTimeLogDto.hoursWorked,
        taskId: createTimeLogDto.taskId,
        workDescription: createTimeLogDto.workDescription,
        workType: createTimeLogDto.workType,
        billable: createTimeLogDto.billable,
        status: 'submitted'
      }
    });

    return timeLog;
  }
}
```

## 6. 维阶段事件详细实现

### 6.1 过程16: 问题诊断与修复

#### 事件8: `DEFECT_REPORTED` - 缺陷报告 (→指标44)
**触发机制**：用户操作触发  
**实现设计**：
- **触发条件**：测试人员或用户发现并报告缺陷
- **数据来源**：缺陷报告表单的详细信息
- **触发流程**：
  1. 用户在缺陷管理界面点击"报告缺陷"
  2. 填写缺陷详细信息（标题、描述、严重程度、重现步骤等）
  3. 上传相关截图或日志文件
  4. 提交缺陷报告
  5. 系统自动分配缺陷ID并设置初始状态
  6. 生成`DEFECT_REPORTED`事件
  7. 更新指标44新增缺陷趋势
- **指标影响**：指标44新增缺陷趋势的缺陷数量+1
- **事件数据结构**：
```json
{
  "eventId": "DEFECT_REPORTED",
  "projectId": "proj_001",
  "timestamp": "2024-01-20T14:30:00Z",
  "triggeredBy": "tester_001",
  "data": {
    "defectId": "def_001",
    "title": "语音通信延迟超过预期",
    "description": "在高负载情况下语音延迟超过100ms，影响实时通信效果",
    "severity": "high",
    "priority": "urgent",
    "component": "voice-communication",
    "version": "v1.2.0",
    "environment": "production",
    "reportedBy": "tester_001",
    "status": "open",
    "stepsToReproduce": [
      "启动语音通信功能",
      "连接10个以上用户",
      "发送语音消息",
      "观察延迟时间"
    ],
    "expectedResult": "语音延迟应小于100ms",
    "actualResult": "语音延迟达到150-200ms",
    "attachments": ["screenshot_001.png", "log_file.txt"]
  }
}
```
- **前端缺陷报告组件**：
```vue
<template>
  <div class="defect-report">
    <el-card title="缺陷报告">
      <el-form :model="defectForm" :rules="rules" ref="formRef" label-width="120px">
        <el-form-item label="缺陷标题" prop="title">
          <el-input v-model="defectForm.title" placeholder="请简洁描述缺陷" />
        </el-form-item>
        
        <el-form-item label="缺陷描述" prop="description">
          <el-input 
            v-model="defectForm.description" 
            type="textarea" 
            :rows="4"
            placeholder="请详细描述缺陷现象和影响"
          />
        </el-form-item>
        
        <el-form-item label="严重程度" prop="severity">
          <el-radio-group v-model="defectForm.severity">
            <el-radio label="critical">严重</el-radio>
            <el-radio label="high">高</el-radio>
            <el-radio label="medium">中</el-radio>
            <el-radio label="low">低</el-radio>
          </el-radio-group>
        </el-form-item>
        
        <el-form-item label="优先级" prop="priority">
          <el-radio-group v-model="defectForm.priority">
            <el-radio label="urgent">紧急</el-radio>
            <el-radio label="high">高</el-radio>
            <el-radio label="medium">中</el-radio>
            <el-radio label="low">低</el-radio>
          </el-radio-group>
        </el-form-item>
        
        <el-form-item label="所属模块" prop="component">
          <el-select v-model="defectForm.component" placeholder="选择相关模块">
            <el-option label="语音通信" value="voice-communication" />
            <el-option label="数据传输" value="data-transmission" />
            <el-option label="用户认证" value="user-authentication" />
            <el-option label="系统配置" value="system-configuration" />
            <el-option label="其他" value="other" />
          </el-select>
        </el-form-item>
        
        <el-form-item label="发现版本" prop="version">
          <el-select v-model="defectForm.version" placeholder="选择版本">
            <el-option 
              v-for="version in availableVersions" 
              :key="version.id"
              :label="version.name" 
              :value="version.name"
            />
          </el-select>
        </el-form-item>
        
        <el-form-item label="运行环境" prop="environment">
          <el-select v-model="defectForm.environment">
            <el-option label="开发环境" value="development" />
            <el-option label="测试环境" value="testing" />
            <el-option label="预生产环境" value="staging" />
            <el-option label="生产环境" value="production" />
          </el-select>
        </el-form-item>
        
        <el-form-item label="重现步骤" prop="stepsToReproduce">
          <div v-for="(step, index) in defectForm.stepsToReproduce" :key="index" class="step-item">
            <el-input 
              v-model="defectForm.stepsToReproduce[index]" 
              :placeholder="`步骤 ${index + 1}`"
            />
            <el-button 
              type="danger" 
              size="small" 
              @click="removeStep(index)"
              v-if="defectForm.stepsToReproduce.length > 1"
            >
              删除
            </el-button>
          </div>
          <el-button type="primary" size="small" @click="addStep">添加步骤</el-button>
        </el-form-item>
        
        <el-form-item label="期望结果" prop="expectedResult">
          <el-input 
            v-model="defectForm.expectedResult" 
            type="textarea" 
            :rows="2"
            placeholder="描述期望的正确行为"
          />
        </el-form-item>
        
        <el-form-item label="实际结果" prop="actualResult">
          <el-input 
            v-model="defectForm.actualResult" 
            type="textarea" 
            :rows="2"
            placeholder="描述实际发生的错误行为"
          />
        </el-form-item>
        
        <el-form-item label="附件">
          <el-upload
            ref="uploadRef"
            :action="uploadAction"
            :headers="uploadHeaders"
            :file-list="fileList"
            :on-success="handleUploadSuccess"
            :before-upload="beforeUpload"
            multiple
          >
            <el-button type="primary">上传文件</el-button>
            <template #tip>
              <div class="el-upload__tip">
                支持截图、日志文件等，单个文件不超过10MB
              </div>
            </template>
          </el-upload>
        </el-form-item>
      </el-form>
      
      <div class="form-actions">
        <el-button @click="resetForm">重置</el-button>
        <el-button type="primary" @click="submitDefect" :loading="submitting">
          提交缺陷报告
        </el-button>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue';
import { ElMessage } from 'element-plus';
import { defectApi } from '@/api/defect';
import { versionApi } from '@/api/version';

const props = defineProps<{
  projectId: string;
}>();

const defectForm = reactive({
  title: '',
  description: '',
  severity: 'medium',
  priority: 'medium',
  component: '',
  version: '',
  environment: 'testing',
  stepsToReproduce: [''],
  expectedResult: '',
  actualResult: '',
  attachments: []
});

const availableVersions = ref([]);
const fileList = ref([]);
const submitting = ref(false);

const rules = {
  title: [{ required: true, message: '请输入缺陷标题', trigger: 'blur' }],
  description: [{ required: true, message: '请输入缺陷描述', trigger: 'blur' }],
  component: [{ required: true, message: '请选择所属模块', trigger: 'change' }],
  version: [{ required: true, message: '请选择发现版本', trigger: 'change' }],
  expectedResult: [{ required: true, message: '请描述期望结果', trigger: 'blur' }],
  actualResult: [{ required: true, message: '请描述实际结果', trigger: 'blur' }]
};

onMounted(async () => {
  await loadVersions();
});

async function loadVersions() {
  try {
    const response = await versionApi.getProjectVersions(props.projectId);
    availableVersions.value = response.data;
  } catch (error) {
    ElMessage.error('加载版本列表失败');
  }
}

function addStep() {
  defectForm.stepsToReproduce.push('');
}

function removeStep(index: number) {
  defectForm.stepsToReproduce.splice(index, 1);
}

function handleUploadSuccess(response: any, file: any) {
  defectForm.attachments.push(response.data.filename);
  ElMessage.success('文件上传成功');
}

function beforeUpload(file: any) {
  const isValidType = ['image/jpeg', 'image/png', 'text/plain', 'application/json'].includes(file.type);
  const isLt10M = file.size / 1024 / 1024 < 10;

  if (!isValidType) {
    ElMessage.error('只支持图片和文本文件');
    return false;
  }
  if (!isLt10M) {
    ElMessage.error('文件大小不能超过10MB');
    return false;
  }
  return true;
}

async function submitDefect() {
  try {
    const formRef = this.$refs.formRef;
    await formRef.validate();
    
    submitting.value = true;
    
    // 过滤空的重现步骤
    const filteredSteps = defectForm.stepsToReproduce.filter(step => step.trim() !== '');
    
    const defectData = {
      ...defectForm,
      stepsToReproduce: filteredSteps
    };
    
    await defectApi.create(props.projectId, defectData);
    ElMessage.success('缺陷报告提交成功');
    
    // 重置表单
    resetForm();
  } catch (error) {
    ElMessage.error('缺陷报告提交失败');
  } finally {
    submitting.value = false;
  }
}

function resetForm() {
  Object.assign(defectForm, {
    title: '',
    description: '',
    severity: 'medium',
    priority: 'medium',
    component: '',
    version: '',
    environment: 'testing',
    stepsToReproduce: [''],
    expectedResult: '',
    actualResult: '',
    attachments: []
  });
  fileList.value = [];
}
</script>
```

## 7. 事件处理架构

### 7.1 事件总线系统
```typescript
// 事件总线接口
interface EventBus {
  publish(event: Event): Promise<void>;
  subscribe(eventType: string, handler: EventHandler): void;
  unsubscribe(eventType: string, handler: EventHandler): void;
}

// 事件处理器接口
interface EventHandler {
  handle(event: Event): Promise<void>;
}

// 事件总线实现
@Injectable()
export class EventBusService implements EventBus {
  private handlers = new Map<string, EventHandler[]>();
  private eventQueue = new Queue('event-processing');

  async publish(event: Event): Promise<void> {
    // 1. 持久化事件
    await this.eventRepository.save(event);
    
    // 2. 添加到处理队列
    await this.eventQueue.add('process-event', event);
    
    // 3. 同步处理（用于实时指标更新）
    const handlers = this.handlers.get(event.eventId) || [];
    for (const handler of handlers) {
      try {
        await handler.handle(event);
      } catch (error) {
        console.error(`事件处理失败: ${event.eventId}`, error);
      }
    }
  }

  subscribe(eventType: string, handler: EventHandler): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler);
  }

  unsubscribe(eventType: string, handler: EventHandler): void {
    const handlers = this.handlers.get(eventType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }
}
```

### 7.2 指标计算处理器
```typescript
// 指标计算处理器
@Injectable()
export class MetricCalculationHandler implements EventHandler {
  constructor(
    private readonly metricService: MetricService,
    private readonly websocketGateway: WebSocketGateway
  ) {}

  async handle(event: Event): Promise<void> {
    // 获取受影响的指标
    const affectedMetrics = await this.getAffectedMetrics(event.eventId);
    
    for (const metricId of affectedMetrics) {
      try {
        // 重新计算指标
        const newValue = await this.metricService.calculateMetric(
          event.projectId, 
          metricId
        );
        
        // 更新指标值
        await this.metricService.updateMetricValue(
          event.projectId, 
          metricId, 
          newValue
        );
        
        // 推送到前端
        await this.websocketGateway.sendMetricUpdate(
          event.projectId, 
          metricId, 
          newValue
        );
        
        console.log(`指标 ${metricId} 已更新: ${newValue}`);
      } catch (error) {
        console.error(`指标计算失败: ${metricId}`, error);
      }
    }
  }

  private async getAffectedMetrics(eventId: string): Promise<string[]> {
    // 事件与指标的映射关系
    const eventMetricMapping = {
      'PROJECT_INITIATED': [],
      'WORK_ITEM_CREATED': ['metric_3'],
      'REQUIREMENT_CREATED': ['metric_45'],
      'CODE_COMMITTED': ['metric_20', 'metric_21'],
      'BUILD_TASK_FAILED': ['metric_27'],
      'TIME_LOG_RECORDED': ['metric_7'],
      'DEFECT_REPORTED': ['metric_44']
      // ... 更多映射关系
    };
    
    return eventMetricMapping[eventId] || [];
  }
}
```

## 8. 模拟数据生成机制

### 8.1 模拟事件生成器

**核心设计**：由于这是模拟系统，所有事件都通过算法生成，而不是真实的用户操作：

```typescript
// 模拟事件生成器
class SimulationEventGenerator {
  // 根据项目配置生成事件序列
  generateEventSequence(projectConfig: ProjectConfig): Event[] {
    const events: Event[] = [];
    const phases = ['research', 'build', 'use', 'manage', 'maintain'];
    
    phases.forEach(phase => {
      const phaseEvents = this.generatePhaseEvents(phase, projectConfig);
      events.push(...phaseEvents);
    });
    
    return events;
  }
  
  // 生成特定阶段的事件
  private generatePhaseEvents(phase: PhaseType, config: ProjectConfig): Event[] {
    const events: Event[] = [];
    const phaseDuration = this.getPhaseDuration(phase);
    const eventInterval = phaseDuration / this.getEventCount(phase, config);
    
    for (let i = 0; i < this.getEventCount(phase, config); i++) {
      const eventTime = new Date(Date.now() + i * eventInterval);
      const event = this.generateRandomEvent(phase, config, eventTime);
      events.push(event);
    }
    
    return events;
  }
  
  // 生成随机事件
  private generateRandomEvent(phase: PhaseType, config: ProjectConfig, timestamp: Date): Event {
    const eventTypes = this.getEventTypesForPhase(phase);
    const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
    
    return {
      eventId: eventType,
      projectId: config.id,
      timestamp,
      triggeredBy: this.getRandomTeamMember(config.team),
      data: this.generateEventData(eventType, config)
    };
  }
}
```

### 8.2 模拟数据算法

**代码提交模拟**：
```typescript
// 代码提交事件模拟
class CodeCommitSimulator {
  simulateCommits(projectConfig: ProjectConfig, timeRange: Date[]): CodeCommitEvent[] {
    const events: CodeCommitEvent[] = [];
    const developers = projectConfig.team.filter(m => m.role === 'developer');
    
    timeRange.forEach(date => {
      // 每个开发者每天提交1-5次
      developers.forEach(dev => {
        const dailyCommits = Math.floor(Math.random() * 5) + 1;
        for (let i = 0; i < dailyCommits; i++) {
          events.push({
            eventId: 'CODE_COMMITTED',
            projectId: projectConfig.id,
            timestamp: this.randomTimeInDay(date),
            triggeredBy: dev.id,
            data: {
              commitId: this.generateCommitId(),
              author: dev.name,
              message: this.generateCommitMessage(),
              filesChanged: Math.floor(Math.random() * 10) + 1,
              linesAdded: Math.floor(Math.random() * 200) + 10,
              linesDeleted: Math.floor(Math.random() * 50)
            }
          });
        }
      });
    });
    
    return events;
  }
  
  private generateCommitMessage(): string {
    const messages = [
      '实现用户登录功能',
      '修复数据验证bug',
      '优化数据库查询性能',
      '添加单元测试',
      '重构代码结构',
      '更新API文档',
      '修复内存泄漏问题',
      '实现缓存机制',
      '添加错误处理',
      '优化界面响应速度'
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  }
}
```

**缺陷报告模拟**：
```typescript
// 缺陷报告事件模拟
class DefectReportSimulator {
  simulateDefects(projectConfig: ProjectConfig, timeRange: Date[]): DefectEvent[] {
    const events: DefectEvent[] = [];
    const testers = projectConfig.team.filter(m => m.role === 'tester');
    
    timeRange.forEach(date => {
      // 每天可能发现0-3个缺陷
      const dailyDefects = Math.floor(Math.random() * 4);
      for (let i = 0; i < dailyDefects; i++) {
        events.push({
          eventId: 'DEFECT_REPORTED',
          projectId: projectConfig.id,
          timestamp: this.randomTimeInDay(date),
          triggeredBy: this.getRandomTester(testers),
          data: {
            defectId: this.generateDefectId(),
            title: this.generateDefectTitle(),
            severity: this.getRandomSeverity(),
            component: this.getRandomComponent(),
            description: this.generateDefectDescription()
          }
        });
      }
    });
    
    return events;
  }
  
  private getRandomSeverity(): string {
    const severities = ['low', 'medium', 'high', 'critical'];
    const weights = [0.4, 0.3, 0.2, 0.1]; // 权重分布
    return this.weightedRandom(severities, weights);
  }
}
```

### 8.3 模拟时间控制

**时间推进机制**：
```typescript
// 模拟时间控制器
class SimulationTimeController {
  private simulationSpeed: number = 1.0;
  private isPaused: boolean = false;
  private currentSimulationTime: Date = new Date();
  private startTime: Date = new Date();
  
  // 推进模拟时间
  advanceTime(realTimeMs: number): void {
    if (!this.isPaused) {
      const simulatedTimeMs = realTimeMs * this.simulationSpeed;
      this.currentSimulationTime = new Date(
        this.currentSimulationTime.getTime() + simulatedTimeMs
      );
    }
  }
  
  // 获取当前模拟时间
  getCurrentTime(): Date {
    return this.currentSimulationTime;
  }
  
  // 设置模拟速度
  setSpeed(speed: number): void {
    this.simulationSpeed = Math.max(0.1, Math.min(5.0, speed));
  }
  
  // 暂停/继续
  togglePause(): void {
    this.isPaused = !this.isPaused;
  }
}
```

## 9. 总结

通过详细的模拟系统设计，我们明确了：

### 9.1 模拟系统特点

1. **教学导向**：专门用于演示"研建用管维"开发过程
2. **数据模拟**：所有事件都通过算法生成，不依赖真实操作
3. **流程完整**：完整模拟五个阶段的开发过程
4. **指标准确**：基于真实指标公式计算效能数据
5. **交互灵活**：支持手动、自动、混合三种模式

### 9.2 实现优势

1. **可控性强**：可以精确控制模拟的节奏和参数
2. **可重复性**：相同的配置会产生相似的模拟结果
3. **教学效果好**：清晰展示开发过程和效能指标
4. **数据真实**：基于真实开发经验生成合理的模拟数据
5. **扩展性好**：易于添加新的事件类型和指标

### 9.3 应用价值

1. **过程演示**：清晰展示软件开发的完整过程
2. **效能教学**：帮助理解效能指标的含义和计算方法
3. **团队培训**：提升团队对开发过程的认识
4. **管理研究**：为项目管理研究提供数据支持
5. **工具验证**：验证效能度量工具的有效性

这种模拟系统设计确保了：
- **事件可追溯**：每个模拟事件都有明确的生成逻辑
- **数据合理性**：基于真实开发经验生成合理的模拟数据
- **实时性**：模拟事件按预定节奏触发指标计算
- **可维护性**：清晰的模拟算法和数据结构
- **可扩展性**：支持新的事件类型和指标的添加
