# 后端架构设计详细说明

## 1. 后端总体架构

### 1.1 架构原则
- **模块化设计**：各模块职责明确，低耦合高内聚
- **数据驱动**：基于配置文件驱动业务流程
- **事件驱动**：通过事件机制实现模块间通信
- **多线程支持**：每个项目独立线程执行
- **可扩展性**：支持新增业务模块和指标

### 1.2 技术栈选型

| 技术领域 | 技术选择 | 说明 |
|---------|----------|------|
| 运行时 | Node.js | 跨平台JavaScript运行环境 |
| Web框架 | Express.js | 轻量级Web应用框架 |
| 数据库 | SQLite | 嵌入式数据库，适合桌面应用 |
| ORM | Sequelize | Node.js ORM框架 |
| 任务调度 | node-cron | 定时任务调度 |
| 文件处理 | multer + mammoth | 文件上传和文档解析 |
| 进程通信 | EventEmitter | Node.js事件系统 |
| 日志系统 | winston | 结构化日志记录 |

### 1.3 架构层次图

```
┌─────────────────────────────────────────────────────────────┐
│                    API接口层                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   项目API   │ │   员工API   │ │   数据API   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
├─────────────────────────────────────────────────────────────┤
│                    业务逻辑层                               │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   项目管理   │ │   流程引擎   │ │   员工管理   │          │
│  │   服务      │ │   服务      │ │   服务      │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   指标计算   │ │   文件管理   │ │   事件处理   │          │
│  │   服务      │ │   服务      │ │   服务      │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
├─────────────────────────────────────────────────────────────┤
│                    数据访问层                               │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   数据模型   │ │   仓储接口   │ │   数据库连接  │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
├─────────────────────────────────────────────────────────────┤
│                    数据存储层                               │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   SQLite    │ │   文件系统   │ │   配置文件   │          │
│  │   数据库    │ │   存储      │ │   管理      │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

## 2. 核心模块设计

### 2.1 项目管理模块 (ProjectManager)

**职责**：
- 项目生命周期管理
- 项目配置和状态维护
- 多项目并发控制
- 项目数据持久化

**核心类设计**：

```typescript
class ProjectManager {
  private projects: Map<string, Project> = new Map();
  private projectThreads: Map<string, ProjectThread> = new Map();
  
  // 项目管理
  async createProject(config: ProjectConfig): Promise<Project>;
  async deleteProject(projectId: string): Promise<void>;
  async pauseProject(projectId: string): Promise<void>;
  async resumeProject(projectId: string): Promise<void>;
  
  // 项目查询
  async getProject(projectId: string): Promise<Project>;
  async getAllProjects(): Promise<Project[]>;
  async getProjectsByStatus(status: ProjectStatus): Promise<Project[]>;
  
  // 项目状态更新
  async updateProjectStatus(projectId: string, status: ProjectStatus): Promise<void>;
  async updateProjectProgress(projectId: string, progress: number): Promise<void>;
  
  // 事件处理
  private handleProjectEvent(event: ProjectEvent): void;
}

class Project {
  id: string;
  name: string;
  description: string;
  status: ProjectStatus;
  currentPhase: PhaseType;
  progress: number;
  budget: Budget;
  team: Employee[];
  config: ProjectConfig;
  createdAt: Date;
  updatedAt: Date;
  
  // 项目操作
  start(): void;
  pause(): void;
  resume(): void;
  complete(): void;
  
  // 阶段管理
  getCurrentPhase(): Phase;
  moveToNextPhase(): void;
  
  // 团队管理
  assignEmployee(employeeId: string, role: string): void;
  removeEmployee(employeeId: string): void;
  
  // 预算管理
  consumeBudget(amount: number): boolean;
  getRemainingBudget(): number;
}

interface ProjectConfig {
  name: string;
  description: string;
  budget: number;
  resourceTemplate: ResourceTemplate;
  timeMultiplier: number;
  phases: PhaseConfig[];
}

interface Budget {
  total: number;
  used: number;
  remaining: number;
  dailyCost: number;
}
```

**数据模型**：

```sql
-- 项目表
CREATE TABLE projects (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'pending',
  current_phase TEXT NOT NULL DEFAULT 'research',
  progress REAL DEFAULT 0,
  budget_total REAL NOT NULL,
  budget_used REAL DEFAULT 0,
  time_multiplier REAL DEFAULT 1.0,
  config TEXT, -- JSON格式配置
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 项目团队表
CREATE TABLE project_teams (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  employee_id TEXT NOT NULL,
  role TEXT NOT NULL,
  assigned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (project_id) REFERENCES projects(id),
  FOREIGN KEY (employee_id) REFERENCES employees(id)
);
```

### 2.2 流程引擎模块 (ProcessEngine)

**职责**：
- 项目流程定义和执行
- 任务调度和状态管理
- 事件触发和处理
- 流程配置解析
- 手动/自动执行模式控制

**执行模式设计**：
- **手动模式**：所有任务进展需要用户手动点击触发
- **自动模式**：系统自动填充任务数据和进度，但需用户确认后才正式更新
- **混合模式**：自动执行基础流程，允许用户随时手动干预和调整
- 自动模式下系统会生成数据预览，用户可选择确认、修改或重新生成

**核心类设计**：

```typescript
class ProcessEngine {
  private processDefinitions: Map<string, ProcessDefinition> = new Map();
  private runningProcesses: Map<string, ProcessInstance> = new Map();
  private taskScheduler: TaskScheduler;
  
  // 流程定义管理
  loadProcessDefinition(filePath: string): ProcessDefinition;
  registerProcessDefinition(definition: ProcessDefinition): void;
  
  // 流程实例管理
  startProcess(projectId: string, definitionId: string): ProcessInstance;
  pauseProcess(processId: string): void;
  resumeProcess(processId: string): void;
  terminateProcess(processId: string): void;
  
  // 任务执行
  executeTask(taskId: string): Promise<TaskResult>;
  completeTask(taskId: string, result: TaskResult): void;
  
  // 事件处理
  triggerEvent(event: ProcessEvent): void;
  handleEvent(event: ProcessEvent): void;
}

class ProcessInstance {
  id: string;
  projectId: string;
  definitionId: string;
  status: ProcessStatus;
  currentPhase: string;
  currentTask: string;
  variables: Map<string, any>;
  
  // 流程控制
  moveToNextTask(): void;
  moveToNextPhase(): void;
  rollbackToTask(taskId: string): void;
  
  // 变量管理
  setVariable(key: string, value: any): void;
  getVariable(key: string): any;
}

class TaskScheduler {
  private taskQueue: PriorityQueue<Task> = new PriorityQueue();
  private executingTasks: Map<string, Task> = new Map();
  
  // 任务调度
  scheduleTask(task: Task): void;
  executeNextTask(): Promise<void>;
  cancelTask(taskId: string): void;
  
  // 任务监控
  getTaskStatus(taskId: string): TaskStatus;
  getQueuedTasks(): Task[];
  getExecutingTasks(): Task[];
}

interface ProcessDefinition {
  id: string;
  name: string;
  version: string;
  phases: PhaseDefinition[];
  events: EventDefinition[];
  variables: VariableDefinition[];
}

interface PhaseDefinition {
  id: string;
  name: string;
  displayName: string;
  tasks: TaskDefinition[];
  conditions: ConditionDefinition[];
}

interface TaskDefinition {
  id: string;
  name: string;
  type: TaskType;
  duration: number;
  requiredRole: string;
  dependencies: string[];
  events: string[];
  script?: string; // 可执行脚本
}
```

**任务事件模板设计**：
- 基于《研建用管维角色关系与效能指标体系分析.md》中的17个关键任务
- 每个任务细化为具体的事件序列，如编码实现包含：代码框架搭建→核心功能开发→代码提交→单元测试→代码审查→分支合并→构建验证
- 支持事件失败和重试机制，如构建失败→问题修复→重新构建
- 每个事件都有明确的持续时间和对效能指标的影响值

**流程配置文件格式**：

```json
{
  "id": "standard_sdlc",
  "name": "标准软件开发生命周期",
  "version": "1.0",
  "phases": [
    {
      "id": "research",
      "name": "research",
      "displayName": "研阶段",
      "tasks": [
        {
          "id": "requirement_analysis",
          "name": "需求分析",
          "type": "manual",
          "duration": 5,
          "requiredRole": "research",
          "dependencies": [],
          "events": [
            {
              "type": "task_start",
              "description": "开始需求分析",
              "metrics": {
                "requirement_completeness": 0
              }
            },
            {
              "type": "document_upload",
              "description": "上传SRS文档",
              "metrics": {
                "document_quality": "+10"
              }
            },
            {
              "type": "task_complete",
              "description": "完成需求分析",
              "metrics": {
                "requirement_completeness": 100,
                "phase_progress": "+20"
              }
            }
          ]
        },
        {
          "id": "requirement_review",
          "name": "需求评审",
          "type": "automatic",
          "duration": 2,
          "requiredRole": "research",
          "dependencies": ["requirement_analysis"],
          "events": [
            {
              "type": "review_start",
              "description": "开始需求评审",
              "script": "callAIReviewService()"
            },
            {
              "type": "review_complete",
              "description": "完成需求评审",
              "metrics": {
                "review_score": "calculated",
                "requirement_quality": "calculated"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "build",
      "name": "build",
      "displayName": "建阶段",
      "tasks": [
        {
          "id": "architecture_design",
          "name": "架构设计",
          "type": "manual",
          "duration": 8,
          "requiredRole": "build",
          "dependencies": [],
          "events": [
            {
              "type": "design_start",
              "description": "开始架构设计"
            },
            {
              "type": "design_complete",
              "description": "完成架构设计",
              "metrics": {
                "design_completeness": 100
              }
            }
          ]
        }
      ]
    }
  ],
  "globalEvents": [
    {
      "id": "budget_insufficient",
      "name": "预算不足",
      "trigger": "budget.remaining < 1000",
      "action": "pauseProject"
    },
    {
      "id": "requirement_change",
      "name": "需求变更",
      "trigger": "manual",
      "action": "triggerChangeProcess"
    }
  ]
}
```

### 2.3 员工管理模块 (EmployeeManager)

**职责**：
- 员工信息管理
- 任务分配和调度
- 工资计算和预算扣除
- 绩效评估和积分管理

**核心类设计**：

```typescript
class EmployeeManager {
  private employees: Map<string, Employee> = new Map();
  private assignmentStrategy: AssignmentStrategy;
  
  // 员工管理
  async createEmployee(config: EmployeeConfig): Promise<Employee>;
  async updateEmployee(employeeId: string, updates: Partial<Employee>): Promise<void>;
  async deleteEmployee(employeeId: string): Promise<void>;
  
  // 员工查询
  async getEmployee(employeeId: string): Promise<Employee>;
  async getEmployeesByRole(role: string): Promise<Employee[]>;
  async getAvailableEmployees(): Promise<Employee[]>;
  
  // 任务分配
  async assignTask(task: Task): Promise<Employee>;
  async unassignTask(taskId: string): Promise<void>;
  async reassignTask(taskId: string, newEmployeeId: string): Promise<void>;
  
  // 工资和绩效
  async calculateDailySalary(employeeId: string): Promise<number>;
  async updateEmployeeScore(employeeId: string, scoreChange: number): Promise<void>;
  async getEmployeePerformance(employeeId: string): Promise<Performance>;
  
  // 状态管理
  async updateEmployeeStatus(employeeId: string, status: EmployeeStatus): Promise<void>;
  async getEmployeeWorkload(employeeId: string): Promise<number>;
}

class Employee {
  id: string;
  name: string;
  role: EmployeeRole;
  status: EmployeeStatus;
  efficiency: number; // 工作效率系数 0.5-2.0
  dailySalary: number;
  totalScore: number;
  currentTasks: Task[];
  completedTasks: Task[];
  skills: string[];
  experience: number;
  
  // 任务管理
  assignTask(task: Task): void;
  completeTask(taskId: string): void;
  getCurrentWorkload(): number;
  
  // 绩效计算
  calculateEfficiency(): number;
  updateScore(change: number): void;
  getPerformanceMetrics(): PerformanceMetrics;
}

interface EmployeeConfig {
  name: string;
  role: EmployeeRole;
  dailySalary: number;
  efficiency?: number;
  skills?: string[];
  experience?: number;
}

interface Performance {
  totalTasks: number;
  completedTasks: number;
  averageCompletionTime: number;
  qualityScore: number;
  efficiency: number;
  totalScore: number;
}

enum EmployeeRole {
  RESEARCH = 'research',
  BUILD = 'build',
  USE = 'use',
  MANAGE = 'manage',
  MAINTAIN = 'maintain'
}

enum EmployeeStatus {
  IDLE = 'idle',
  WORKING = 'working',
  OFFLINE = 'offline'
}
```

**任务分配策略**：

```typescript
interface AssignmentStrategy {
  assignTask(task: Task, availableEmployees: Employee[]): Employee;
}

class SkillBasedAssignmentStrategy implements AssignmentStrategy {
  assignTask(task: Task, availableEmployees: Employee[]): Employee {
    // 基于技能匹配度分配任务
    const candidates = availableEmployees
      .filter(emp => emp.role === task.requiredRole)
      .filter(emp => emp.status === EmployeeStatus.IDLE)
      .sort((a, b) => this.calculateMatchScore(task, b) - this.calculateMatchScore(task, a));
    
    return candidates[0] || null;
  }
  
  private calculateMatchScore(task: Task, employee: Employee): number {
    let score = employee.efficiency * 0.4;
    score += employee.experience * 0.3;
    score += this.skillMatch(task.requiredSkills, employee.skills) * 0.3;
    return score;
  }
}

class LoadBalancingAssignmentStrategy implements AssignmentStrategy {
  assignTask(task: Task, availableEmployees: Employee[]): Employee {
    // 基于工作负载平衡分配任务
    const candidates = availableEmployees
      .filter(emp => emp.role === task.requiredRole)
      .sort((a, b) => a.getCurrentWorkload() - b.getCurrentWorkload());
    
    return candidates[0] || null;
  }
}
```

### 2.4 指标计算模块 (MetricsCalculator)

**职责**：
- 40个效能指标的定义和计算
- 实时指标更新
- 指标历史数据管理
- 异常检测和告警

**指标计算逻辑**：
- 基于《研建用管维角色关系与效能指标体系分析.md》中定义的指标公式
- 每个任务事件完成时触发相关指标的重新计算
- 支持指标间的依赖关系计算，如综合效能指数依赖多个子指标
- 提供指标阈值设置和异常告警机制

**核心类设计**：

```typescript
class MetricsCalculator {
  private metricDefinitions: Map<string, MetricDefinition> = new Map();
  private calculators: Map<string, MetricCalculator> = new Map();
  private alertRules: Map<string, AlertRule> = new Map();
  
  // 指标定义管理
  registerMetric(definition: MetricDefinition): void;
  getMetricDefinition(metricId: string): MetricDefinition;
  
  // 指标计算
  async calculateMetric(metricId: string, projectId: string): Promise<MetricValue>;
  async calculateAllMetrics(projectId: string): Promise<Map<string, MetricValue>>;
  async updateMetric(metricId: string, projectId: string, value: any): Promise<void>;
  
  // 指标查询
  async getMetricValue(metricId: string, projectId: string): Promise<MetricValue>;
  async getMetricHistory(metricId: string, projectId: string, timeRange: TimeRange): Promise<MetricValue[]>;
  async getMetricsByCategory(category: string, projectId: string): Promise<Map<string, MetricValue>>;
  
  // 异常检测
  checkAlerts(projectId: string): Promise<Alert[]>;
  evaluateAlertRule(rule: AlertRule, metricValue: MetricValue): boolean;
}

interface MetricDefinition {
  id: string;
  name: string;
  description: string;
  category: MetricCategory;
  unit: string;
  type: MetricType;
  calculationFormula: string;
  dependencies: string[];
  alertRules: AlertRule[];
}

interface MetricValue {
  metricId: string;
  projectId: string;
  value: number | string;
  timestamp: Date;
  trend: TrendType;
  changePercent: number;
}

enum MetricCategory {
  QUALITY = 'quality',
  PROGRESS = 'progress',
  COST = 'cost',
  RISK = 'risk',
  EFFICIENCY = 'efficiency'
}

enum MetricType {
  COUNTER = 'counter',
  GAUGE = 'gauge',
  HISTOGRAM = 'histogram',
  SUMMARY = 'summary'
}
```

**40个效能指标定义**：

```typescript
const METRIC_DEFINITIONS: MetricDefinition[] = [
  // 质量指标 (10个)
  {
    id: 'requirement_completeness',
    name: '需求完成度',
    category: MetricCategory.QUALITY,
    unit: '%',
    type: MetricType.GAUGE,
    calculationFormula: '(completedRequirements / totalRequirements) * 100',
    dependencies: ['completed_requirements', 'total_requirements']
  },
  {
    id: 'defect_density',
    name: '缺陷密度',
    category: MetricCategory.QUALITY,
    unit: '个/KLOC',
    type: MetricType.GAUGE,
    calculationFormula: 'totalDefects / (codeLines / 1000)',
    dependencies: ['total_defects', 'code_lines']
  },
  {
    id: 'code_coverage',
    name: '代码覆盖率',
    category: MetricCategory.QUALITY,
    unit: '%',
    type: MetricType.GAUGE,
    calculationFormula: '(coveredLines / totalLines) * 100',
    dependencies: ['covered_lines', 'total_lines']
  },
  {
    id: 'review_efficiency',
    name: '评审效率',
    category: MetricCategory.QUALITY,
    unit: '个/小时',
    type: MetricType.GAUGE,
    calculationFormula: 'reviewedItems / reviewTime',
    dependencies: ['reviewed_items', 'review_time']
  },
  
  // 进度指标 (10个)
  {
    id: 'schedule_performance_index',
    name: '进度绩效指数',
    category: MetricCategory.PROGRESS,
    unit: '',
    type: MetricType.GAUGE,
    calculationFormula: 'earnedValue / plannedValue',
    dependencies: ['earned_value', 'planned_value']
  },
  {
    id: 'milestone_completion_rate',
    name: '里程碑完成率',
    category: MetricCategory.PROGRESS,
    unit: '%',
    type: MetricType.GAUGE,
    calculationFormula: '(completedMilestones / totalMilestones) * 100',
    dependencies: ['completed_milestones', 'total_milestones']
  },
  {
    id: 'task_completion_rate',
    name: '任务完成率',
    category: MetricCategory.PROGRESS,
    unit: '%',
    type: MetricType.GAUGE,
    calculationFormula: '(completedTasks / totalTasks) * 100',
    dependencies: ['completed_tasks', 'total_tasks']
  },
  {
    id: 'velocity',
    name: '开发速度',
    category: MetricCategory.PROGRESS,
    unit: '故事点/迭代',
    type: MetricType.GAUGE,
    calculationFormula: 'completedStoryPoints / iterationCount',
    dependencies: ['completed_story_points', 'iteration_count']
  },
  
  // 成本指标 (10个)
  {
    id: 'cost_performance_index',
    name: '成本绩效指数',
    category: MetricCategory.COST,
    unit: '',
    type: MetricType.GAUGE,
    calculationFormula: 'earnedValue / actualCost',
    dependencies: ['earned_value', 'actual_cost']
  },
  {
    id: 'budget_utilization',
    name: '预算使用率',
    category: MetricCategory.COST,
    unit: '%',
    type: MetricType.GAUGE,
    calculationFormula: '(usedBudget / totalBudget) * 100',
    dependencies: ['used_budget', 'total_budget']
  },
  {
    id: 'cost_per_defect',
    name: '每缺陷成本',
    category: MetricCategory.COST,
    unit: '元/个',
    type: MetricType.GAUGE,
    calculationFormula: 'totalCost / totalDefects',
    dependencies: ['total_cost', 'total_defects']
  },
  
  // 风险指标 (10个)
  {
    id: 'risk_exposure',
    name: '风险暴露度',
    category: MetricCategory.RISK,
    unit: '',
    type: MetricType.GAUGE,
    calculationFormula: 'sum(riskProbability * riskImpact)',
    dependencies: ['risk_probability', 'risk_impact']
  },
  {
    id: 'technical_debt_ratio',
    name: '技术债务比率',
    category: MetricCategory.RISK,
    unit: '%',
    type: MetricType.GAUGE,
    calculationFormula: '(technicalDebtCost / developmentCost) * 100',
    dependencies: ['technical_debt_cost', 'development_cost']
  }
];
```

### 2.5 文件管理模块 (FileManager)

**职责**：
- 文件上传和存储
- 文档解析和处理
- 里程碑文件生成
- 文件版本管理

**核心类设计**：

```typescript
class FileManager {
  private storageProvider: StorageProvider;
  private documentParser: DocumentParser;
  
  // 文件上传
  async uploadFile(file: File, projectId: string): Promise<FileInfo>;
  async uploadMultipleFiles(files: File[], projectId: string): Promise<FileInfo[]>;
  
  // 文件下载
  async downloadFile(fileId: string): Promise<Buffer>;
  async downloadProjectFiles(projectId: string): Promise<Buffer>; // ZIP格式
  
  // 文档解析
  async parseDocument(fileId: string): Promise<DocumentContent>;
  async extractRequirements(fileId: string): Promise<Requirement[]>;
  
  // 里程碑管理
  async generateMilestone(projectId: string, phase: string): Promise<MilestoneFile>;
  async getMilestones(projectId: string): Promise<MilestoneFile[]>;
  
  // 文件管理
  async getFileInfo(fileId: string): Promise<FileInfo>;
  async deleteFile(fileId: string): Promise<void>;
  async getProjectFiles(projectId: string): Promise<FileInfo[]>;
}

interface FileInfo {
  id: string;
  originalName: string;
  filename: string;
  path: string;
  size: number;
  mimeType: string;
  projectId: string;
  uploadedAt: Date;
  category: FileCategory;
}

interface DocumentContent {
  title: string;
  content: string;
  sections: Section[];
  requirements: Requirement[];
  metadata: DocumentMetadata;
}

interface MilestoneFile {
  id: string;
  projectId: string;
  phase: string;
  name: string;
  description: string;
  deliverables: string[];
  filePath: string;
  createdAt: Date;
}

enum FileCategory {
  REQUIREMENT = 'requirement',
  DESIGN = 'design',
  CODE = 'code',
  TEST = 'test',
  MILESTONE = 'milestone',
  OTHER = 'other'
}
```

### 2.6 事件处理模块 (EventHandler)

**职责**：
- 系统事件定义和处理
- 事件路由和分发
- 事件持久化存储
- 事件驱动的业务逻辑
- 意外事件模拟和处理

**意外事件管理逻辑**：
- **需求变更事件**：在研发和建设阶段随机触发，影响进度和成本
- **严重Bug发现**：在使用和管理阶段触发，启动紧急维护流程
- **人员短缺事件**：在建设和管理阶段触发，需要重新分配资源
- **技术难题事件**：在建设阶段触发，可能延长开发时间但提升质量
- 每种事件都有概率设置、影响系数和应对措施定义

**其他开销计算逻辑**：
- **固定开销**：办公室租金、设备折旧、软件许可等，每日固定扣除
- **变动开销**：水电费、通讯费等，根据团队规模计算
- **偶发开销**：培训费用、会议成本等，按概率随机发生
- 所有开销都会从项目预算中实时扣除，影响项目可持续性

**核心类设计**：

```typescript
class EventHandler {
  private eventBus: EventEmitter;
  private eventHandlers: Map<string, EventHandlerFunction[]> = new Map();
  private eventStore: EventStore;
  
  // 事件注册
  registerHandler(eventType: string, handler: EventHandlerFunction): void;
  unregisterHandler(eventType: string, handler: EventHandlerFunction): void;
  
  // 事件发布
  async publishEvent(event: SystemEvent): Promise<void>;
  async publishEvents(events: SystemEvent[]): Promise<void>;
  
  // 事件处理
  private async handleEvent(event: SystemEvent): Promise<void>;
  private async executeHandlers(eventType: string, event: SystemEvent): Promise<void>;
  
  // 事件查询
  async getEvents(projectId: string, timeRange?: TimeRange): Promise<SystemEvent[]>;
  async getEventsByType(eventType: string, projectId: string): Promise<SystemEvent[]>;
}

interface SystemEvent {
  id: string;
  type: string;
  projectId: string;
  taskId?: string;
  employeeId?: string;
  timestamp: Date;
  data: any;
  source: string;
  metadata?: any;
}

interface EventHandlerFunction {
  (event: SystemEvent): Promise<void>;
}

// 事件类型定义
enum EventType {
  // 项目事件
  PROJECT_CREATED = 'project.created',
  PROJECT_STARTED = 'project.started',
  PROJECT_PAUSED = 'project.paused',
  PROJECT_COMPLETED = 'project.completed',
  
  // 任务事件
  TASK_ASSIGNED = 'task.assigned',
  TASK_STARTED = 'task.started',
  TASK_COMPLETED = 'task.completed',
  TASK_FAILED = 'task.failed',
  
  // 员工事件
  EMPLOYEE_ASSIGNED = 'employee.assigned',
  EMPLOYEE_STATUS_CHANGED = 'employee.status_changed',
  
  // 指标事件
  METRIC_UPDATED = 'metric.updated',
  METRIC_ALERT = 'metric.alert',
  
  // 文件事件
  FILE_UPLOADED = 'file.uploaded',
  DOCUMENT_PARSED = 'document.parsed',
  MILESTONE_GENERATED = 'milestone.generated',
  
  // 异常事件
  BUDGET_INSUFFICIENT = 'budget.insufficient',
  REQUIREMENT_CHANGED = 'requirement.changed',
  BUG_DISCOVERED = 'bug.discovered'
}
```

## 3. 数据层设计

### 3.1 数据模型定义

**使用Sequelize ORM定义数据模型**：

```typescript
// 项目模型
class ProjectModel extends Model {
  public id!: string;
  public name!: string;
  public description!: string;
  public status!: string;
  public currentPhase!: string;
  public progress!: number;
  public budgetTotal!: number;
  public budgetUsed!: number;
  public timeMultiplier!: number;
  public config!: string; // JSON
  public createdAt!: Date;
  public updatedAt!: Date;
}

ProjectModel.init({
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: DataTypes.TEXT,
  status: {
    type: DataTypes.ENUM('pending', 'running', 'paused', 'completed'),
    defaultValue: 'pending'
  },
  currentPhase: {
    type: DataTypes.ENUM('research', 'build', 'use', 'manage', 'maintain'),
    defaultValue: 'research'
  },
  progress: {
    type: DataTypes.FLOAT,
    defaultValue: 0
  },
  budgetTotal: {
    type: DataTypes.FLOAT,
    allowNull: false
  },
  budgetUsed: {
    type: DataTypes.FLOAT,
    defaultValue: 0
  },
  timeMultiplier: {
    type: DataTypes.FLOAT,
    defaultValue: 1.0
  },
  config: DataTypes.TEXT
}, {
  sequelize: database,
  modelName: 'Project',
  tableName: 'projects'
});

// 员工模型
class EmployeeModel extends Model {
  public id!: string;
  public name!: string;
  public role!: string;
  public status!: string;
  public efficiency!: number;
  public dailySalary!: number;
  public totalScore!: number;
  public skills!: string; // JSON数组
  public experience!: number;
  public createdAt!: Date;
  public updatedAt!: Date;
}

// 任务模型
class TaskModel extends Model {
  public id!: string;
  public projectId!: string;
  public name!: string;
  public phase!: string;
  public type!: string;
  public duration!: number;
  public requiredRole!: string;
  public assignedEmployeeId!: string;
  public status!: string;
  public progress!: number;
  public startTime!: Date;
  public endTime!: Date;
  public dependencies!: string; // JSON数组
  public config!: string; // JSON
}

// 指标模型
class MetricModel extends Model {
  public id!: string;
  public projectId!: string;
  public metricId!: string;
  public metricName!: string;
  public category!: string;
  public value!: string; // 支持数字和字符串
  public unit!: string;
  public trend!: string;
  public changePercent!: number;
  public recordedAt!: Date;
}

// 事件模型
class EventModel extends Model {
  public id!: string;
  public type!: string;
  public projectId!: string;
  public taskId!: string;
  public employeeId!: string;
  public timestamp!: Date;
  public data!: string; // JSON
  public source!: string;
  public metadata!: string; // JSON
}
```

### 3.2 数据访问层 (Repository)

**仓储模式实现数据访问**：

```typescript
interface IProjectRepository {
  create(project: Project): Promise<Project>;
  findById(id: string): Promise<Project | null>;
  findAll(): Promise<Project[]>;
  update(id: string, updates: Partial<Project>): Promise<void>;
  delete(id: string): Promise<void>;
  findByStatus(status: ProjectStatus): Promise<Project[]>;
}

class ProjectRepository implements IProjectRepository {
  async create(project: Project): Promise<Project> {
    const model = await ProjectModel.create({
      id: project.id,
      name: project.name,
      description: project.description,
      status: project.status,
      budgetTotal: project.budget.total,
      config: JSON.stringify(project.config)
    });
    
    return this.mapToEntity(model);
  }
  
  async findById(id: string): Promise<Project | null> {
    const model = await ProjectModel.findByPk(id, {
      include: [
        { model: EmployeeModel, as: 'team' },
        { model: TaskModel, as: 'tasks' }
      ]
    });
    
    return model ? this.mapToEntity(model) : null;
  }
  
  private mapToEntity(model: ProjectModel): Project {
    // 将数据库模型转换为业务实体
    return new Project({
      id: model.id,
      name: model.name,
      description: model.description,
      status: model.status as ProjectStatus,
      currentPhase: model.currentPhase as PhaseType,
      progress: model.progress,
      budget: {
        total: model.budgetTotal,
        used: model.budgetUsed,
        remaining: model.budgetTotal - model.budgetUsed,
        dailyCost: 0 // 需要计算
      },
      config: JSON.parse(model.config),
      createdAt: model.createdAt,
      updatedAt: model.updatedAt
    });
  }
}
```

## 4. API接口设计

### 4.1 RESTful API设计

**项目管理API**：

```typescript
// routes/projects.ts
import express from 'express';
import { ProjectController } from '../controllers/ProjectController';

const router = express.Router();
const projectController = new ProjectController();

// 项目CRUD操作
router.post('/', projectController.createProject);
router.get('/', projectController.getAllProjects);
router.get('/:id', projectController.getProject);
router.put('/:id', projectController.updateProject);
router.delete('/:id', projectController.deleteProject);

// 项目控制操作
router.post('/:id/start', projectController.startProject);
router.post('/:id/pause', projectController.pauseProject);
router.post('/:id/resume', projectController.resumeProject);
router.post('/:id/complete', projectController.completeProject);

// 项目数据查询
router.get('/:id/metrics', projectController.getProjectMetrics);
router.get('/:id/tasks', projectController.getProjectTasks);
router.get('/:id/team', projectController.getProjectTeam);
router.get('/:id/milestones', projectController.getProjectMilestones);
router.get('/:id/events', projectController.getProjectEvents);

export default router;
```

**项目控制器**：

```typescript
class ProjectController {
  private projectManager: ProjectManager;
  
  constructor() {
    this.projectManager = new ProjectManager();
  }
  
  createProject = async (req: Request, res: Response) => {
    try {
      const projectConfig: ProjectConfig = req.body;
      const project = await this.projectManager.createProject(projectConfig);
      
      res.status(201).json({
        success: true,
        data: project,
        message: '项目创建成功'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  };
  
  getProject = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const project = await this.projectManager.getProject(id);
      
      if (!project) {
        return res.status(404).json({
          success: false,
          error: '项目不存在'
        });
      }
      
      res.json({
        success: true,
        data: project
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  };
  
  startProject = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await this.projectManager.startProject(id);
      
      res.json({
        success: true,
        message: '项目启动成功'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  };
}
```

### 4.2 WebSocket实时通信

**实时数据推送**：

```typescript
import { Server } from 'socket.io';
import { EventHandler } from '../services/EventHandler';

class WebSocketServer {
  private io: Server;
  private eventHandler: EventHandler;
  
  constructor(server: any) {
    this.io = new Server(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });
    
    this.eventHandler = new EventHandler();
    this.setupEventHandlers();
    this.setupSocketHandlers();
  }
  
  private setupEventHandlers() {
    // 监听系统事件并推送给客户端
    this.eventHandler.registerHandler('metric.updated', async (event) => {
      this.io.to(`project_${event.projectId}`).emit('metricUpdate', {
        metricId: event.data.metricId,
        value: event.data.value,
        timestamp: event.timestamp
      });
    });
    
    this.eventHandler.registerHandler('task.completed', async (event) => {
      this.io.to(`project_${event.projectId}`).emit('taskCompleted', {
        taskId: event.taskId,
        employeeId: event.employeeId,
        completedAt: event.timestamp
      });
    });
    
    this.eventHandler.registerHandler('project.status_changed', async (event) => {
      this.io.to(`project_${event.projectId}`).emit('projectStatusChanged', {
        projectId: event.projectId,
        status: event.data.status,
        changedAt: event.timestamp
      });
    });
  }
  
  private setupSocketHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`Client connected: ${socket.id}`);
      
      // 加入项目房间
      socket.on('joinProject', (projectId: string) => {
        socket.join(`project_${projectId}`);
        console.log(`Client ${socket.id} joined project ${projectId}`);
      });
      
      // 离开项目房间
      socket.on('leaveProject', (projectId: string) => {
        socket.leave(`project_${projectId}`);
        console.log(`Client ${socket.id} left project ${projectId}`);
      });
      
      // 客户端断开连接
      socket.on('disconnect', () => {
        console.log(`Client disconnected: ${socket.id}`);
      });
    });
  }
  
  // 广播消息到指定项目
  broadcastToProject(projectId: string, event: string, data: any) {
    this.io.to(`project_${projectId}`).emit(event, data);
  }
}
```

## 5. 多线程项目执行

### 5.1 项目线程管理

**项目执行线程**：

```typescript
class ProjectThread {
  private projectId: string;
  private processEngine: ProcessEngine;
  private isRunning: boolean = false;
  private isPaused: boolean = false;
  private executionInterval: NodeJS.Timeout | null = null;
  
  constructor(projectId: string) {
    this.projectId = projectId;
    this.processEngine = new ProcessEngine();
  }
  
  async start(): Promise<void> {
    if (this.isRunning) {
      throw new Error('项目已在运行中');
    }
    
    this.isRunning = true;
    this.isPaused = false;
    
    // 启动项目执行循环
    this.executionInterval = setInterval(async () => {
      if (!this.isPaused) {
        await this.executeNextStep();
      }
    }, 1000); // 每秒检查一次
    
    console.log(`项目 ${this.projectId} 开始执行`);
  }
  
  pause(): void {
    this.isPaused = true;
    console.log(`项目 ${this.projectId} 已暂停`);
  }
  
  resume(): void {
    this.isPaused = false;
    console.log(`项目 ${this.projectId} 已恢复`);
  }
  
  stop(): void {
    this.isRunning = false;
    this.isPaused = false;
    
    if (this.executionInterval) {
      clearInterval(this.executionInterval);
      this.executionInterval = null;
    }
    
    console.log(`项目 ${this.projectId} 已停止`);
  }
  
  private async executeNextStep(): Promise<void> {
    try {
      const project = await ProjectRepository.findById(this.projectId);
      if (!project) {
        this.stop();
        return;
      }
      
      // 检查预算是否充足
      if (project.budget.remaining <= 0) {
        await this.handleBudgetInsufficient();
        return;
      }
      
      // 获取当前任务
      const currentTask = await this.getCurrentTask();
      if (!currentTask) {
        await this.moveToNextPhase();
        return;
      }
      
      // 执行当前任务
      await this.executeTask(currentTask);
      
    } catch (error) {
      console.error(`项目 ${this.projectId} 执行出错:`, error);
      await this.handleExecutionError(error);
    }
  }
  
  private async executeTask(task: Task): Promise<void> {
    // 分配员工
    if (!task.assignedEmployeeId) {
      const employee = await EmployeeManager.assignTask(task);
      if (!employee) {
        console.log(`任务 ${task.id} 无可用员工，等待中...`);
        return;
      }
      task.assignedEmployeeId = employee.id;
    }
    
    // 更新任务进度
    const employee = await EmployeeManager.getEmployee(task.assignedEmployeeId);
    const progressIncrement = employee.efficiency * this.getTimeMultiplier();
    
    task.progress += progressIncrement;
    
    // 扣除预算
    const dailyCost = employee.dailySalary / 24; // 每小时成本
    await ProjectManager.consumeBudget(this.projectId, dailyCost);
    
    // 更新指标
    await MetricsCalculator.updateTaskMetrics(task);
    
    // 检查任务是否完成
    if (task.progress >= 100) {
      await this.completeTask(task);
    }
  }
  
  private async completeTask(task: Task): Promise<void> {
    task.status = TaskStatus.COMPLETED;
    task.endTime = new Date();
    
    // 更新员工积分
    const employee = await EmployeeManager.getEmployee(task.assignedEmployeeId);
    const scoreIncrease = this.calculateTaskScore(task);
    await EmployeeManager.updateEmployeeScore(employee.id, scoreIncrease);
    
    // 发布任务完成事件
    await EventHandler.publishEvent({
      type: EventType.TASK_COMPLETED,
      projectId: this.projectId,
      taskId: task.id,
      employeeId: task.assignedEmployeeId,
      timestamp: new Date(),
      data: { scoreIncrease },
      source: 'ProjectThread'
    });
    
    console.log(`任务 ${task.name} 已完成`);
  }
}

class ProjectThreadManager {
  private threads: Map<string, ProjectThread> = new Map();
  
  async startProject(projectId: string): Promise<void> {
    if (this.threads.has(projectId)) {
      throw new Error('项目已在运行中');
    }
    
    const thread = new ProjectThread(projectId);
    this.threads.set(projectId, thread);
    
    await thread.start();
  }
  
  pauseProject(projectId: string): void {
    const thread = this.threads.get(projectId);
    if (thread) {
      thread.pause();
    }
  }
  
  resumeProject(projectId: string): void {
    const thread = this.threads.get(projectId);
    if (thread) {
      thread.resume();
    }
  }
  
  stopProject(projectId: string): void {
    const thread = this.threads.get(projectId);
    if (thread) {
      thread.stop();
      this.threads.delete(projectId);
    }
  }
  
  getRunningProjects(): string[] {
    return Array.from(this.threads.keys());
  }
}
```

## 6. 配置和扩展性

### 6.1 配置管理

**系统配置**：

```typescript
interface SystemConfig {
  database: DatabaseConfig;
  server: ServerConfig;
  metrics: MetricsConfig;
  files: FileConfig;
  ai: AIConfig;
}

interface DatabaseConfig {
  path: string;
  maxConnections: number;
  timeout: number;
}

interface ServerConfig {
  port: number;
  host: string;
  cors: CorsConfig;
}

interface MetricsConfig {
  updateInterval: number;
  alertThreshold: number;
  historyRetention: number;
}

class ConfigManager {
  private config: SystemConfig;
  
  constructor() {
    this.loadConfig();
  }
  
  private loadConfig(): void {
    const configPath = path.join(process.cwd(), 'config', 'system.json');
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
  }
  
  get<T>(key: string): T {
    return this.getNestedValue(this.config, key);
  }
  
  set(key: string, value: any): void {
    this.setNestedValue(this.config, key, value);
    this.saveConfig();
  }
  
  private saveConfig(): void {
    const configPath = path.join(process.cwd(), 'config', 'system.json');
    fs.writeFileSync(configPath, JSON.stringify(this.config, null, 2));
  }
}
```

### 6.2 插件系统

**插件接口**：

```typescript
interface Plugin {
  name: string;
  version: string;
  initialize(context: PluginContext): Promise<void>;
  destroy(): Promise<void>;
}

interface PluginContext {
  eventHandler: EventHandler;
  metricsCalculator: MetricsCalculator;
  projectManager: ProjectManager;
  config: any;
}

class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  private context: PluginContext;
  
  constructor(context: PluginContext) {
    this.context = context;
  }
  
  async loadPlugin(pluginPath: string): Promise<void> {
    const pluginModule = await import(pluginPath);
    const plugin: Plugin = new pluginModule.default();
    
    await plugin.initialize(this.context);
    this.plugins.set(plugin.name, plugin);
    
    console.log(`插件 ${plugin.name} 加载成功`);
  }
  
  async unloadPlugin(pluginName: string): Promise<void> {
    const plugin = this.plugins.get(pluginName);
    if (plugin) {
      await plugin.destroy();
      this.plugins.delete(pluginName);
      console.log(`插件 ${pluginName} 卸载成功`);
    }
  }
  
  getLoadedPlugins(): string[] {
    return Array.from(this.plugins.keys());
  }
}
```

## 7. 日志和监控

### 7.1 日志系统

```typescript
import winston from 'winston';

class Logger {
  private logger: winston.Logger;
  
  constructor() {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' }),
        new winston.transports.Console({
          format: winston.format.simple()
        })
      ]
    });
  }
  
  info(message: string, meta?: any): void {
    this.logger.info(message, meta);
  }
  
  error(message: string, error?: Error): void {
    this.logger.error(message, { error: error?.stack });
  }
  
  warn(message: string, meta?: any): void {
    this.logger.warn(message, meta);
  }
  
  debug(message: string, meta?: any): void {
    this.logger.debug(message, meta);
  }
}

export const logger = new Logger();
```

### 7.2 性能监控

```typescript
class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric> = new Map();
  
  startTimer(name: string): Timer {
    return new Timer(name, this);
  }
  
  recordMetric(name: string, value: number, unit: string): void {
    const metric = this.metrics.get(name) || new PerformanceMetric(name, unit);
    metric.addValue(value);
    this.metrics.set(name, metric);
  }
  
  getMetrics(): Map<string, PerformanceMetric> {
    return new Map(this.metrics);
  }
  
  generateReport(): PerformanceReport {
    const report: PerformanceReport = {
      timestamp: new Date(),
      metrics: {}
    };
    
    for (const [name, metric] of this.metrics) {
      report.metrics[name] = {
        average: metric.getAverage(),
        min: metric.getMin(),
        max: metric.getMax(),
        count: metric.getCount(),
        unit: metric.unit
      };
    }
    
    return report;
  }
}

class Timer {
  private startTime: number;
  private name: string;
  private monitor: PerformanceMonitor;
  
  constructor(name: string, monitor: PerformanceMonitor) {
    this.name = name;
    this.monitor = monitor;
    this.startTime = Date.now();
  }
  
  end(): number {
    const duration = Date.now() - this.startTime;
    this.monitor.recordMetric(this.name, duration, 'ms');
    return duration;
  }
}
```

## 8. 总结

本后端架构设计采用模块化、事件驱动的设计理念，具有以下特点：

1. **清晰的分层架构**：API层、业务逻辑层、数据访问层、存储层职责明确
2. **高度模块化**：各模块独立开发、测试和维护
3. **事件驱动**：通过事件机制实现松耦合的模块通信
4. **多线程支持**：每个项目独立执行，支持并发处理
5. **配置驱动**：业务流程和规则通过配置文件定义
6. **可扩展性**：支持插件系统和自定义指标
7. **实时通信**：WebSocket支持实时数据推送
8. **完整的监控**：日志、性能监控和异常处理

该架构能够满足"研建用管维"演示验证系统的所有功能需求，为前端提供稳定可靠的数据服务和业务支撑。
