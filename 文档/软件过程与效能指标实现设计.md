# 软件过程与效能指标实现设计

## 1. 概述

本文档基于"研建用管维"五个核心阶段，重新设计软件开发过程的时序执行逻辑和效能指标计算体系。通过将开发过程细化为具体的事件序列，实现对94个效能指标的实时计算和动态展示。

### 1.1 核心概念定义

- **过程（Process）**：软件开发生命周期中的关键活动，按"研建用管维"阶段组织
- **事件（Event）**：过程执行中的具体操作和状态变化，是效能指标计算的基础数据源
- **效能指标（Metric）**：基于事件数据计算得出的量化度量值，用于评估开发效能

### 1.2 设计原则

1. **阶段化组织**：按研建用管维五个阶段组织所有过程
2. **事件驱动**：所有效能指标基于具体事件进行计算
3. **数据持久化**：项目数据完整保存，支持中断恢复
4. **实时更新**：事件发生时立即触发相关指标计算
5. **多项目并发**：支持多个项目独立执行和数据隔离

## 2. "研建用管维"阶段过程设计

### 2.1 研阶段（Research Phase）

**核心目标**：需求分析、技术预研、方案设计

#### 过程1：项目启动与规划
**执行角色**：管理者主导，各角色参与
**过程描述**：项目立项、团队组建、初步规划
**细化事件序列**：
1. `PROJECT_INITIATION` - 项目启动申请
2. `TEAM_FORMATION` - 团队成员分配
3. `INITIAL_PLANNING` - 初步计划制定
4. `BUDGET_ALLOCATION` - 预算分配确认
5. `PROJECT_KICKOFF` - 项目启动会议

**关联效能指标**：
- 指标68：项目进展（项目整体进展状态）
- 指标63：项目投入人力排名（项目人力投入对比）

#### 过程2：市场调研与需求收集
**执行角色**：研发人员主导，用户参与
**过程描述**：用户需求收集、市场分析、需求文档编写
**细化事件序列**：
1. `MARKET_RESEARCH_START` - 开始市场调研
2. `USER_INTERVIEW` - 用户访谈
3. `REQUIREMENT_COLLECTION` - 需求收集
4. `REQUIREMENT_ANALYSIS` - 需求分析
5. `REQUIREMENT_DOCUMENTATION` - 需求文档编写
6. `REQUIREMENT_REVIEW` - 需求评审
7. `REQUIREMENT_APPROVAL` - 需求确认

**关联效能指标**：
- 指标45：新增需求趋势（需求输入稳定性）
- 指标54：新增需求概览（需求状态分布）
- 指标94：需求现状概览（需求执行状态）

#### 过程3：技术可行性研究
**执行角色**：研发和建设人员协作
**过程描述**：技术方案评估、可行性分析、架构预设计
**细化事件序列**：
1. `TECH_RESEARCH_START` - 技术调研开始
2. `ARCHITECTURE_DRAFT` - 架构方案草图
3. `TECH_FEASIBILITY_ANALYSIS` - 技术可行性分析
4. `PROTOTYPE_DEVELOPMENT` - 原型开发
5. `TECH_RISK_ASSESSMENT` - 技术风险评估
6. `TECH_SOLUTION_REVIEW` - 技术方案评审
7. `TECH_SOLUTION_APPROVAL` - 技术方案确认

**关联效能指标**：
- 指标69：预估工时按成员排名（个人工作量评估）
- 指标41：存量工作项预估工时按项目排名（项目工作量评估）

#### 过程4：竞品分析与概念验证
**执行角色**：研发人员主导，用户参与验证
**过程描述**：竞品对比分析、概念原型验证
**细化事件序列**：
1. `COMPETITOR_ANALYSIS_START` - 竞品分析开始
2. `FEATURE_COMPARISON` - 功能对比分析
3. `POC_PLANNING` - PoC计划制定
4. `POC_DEVELOPMENT` - 概念验证开发
5. `POC_TESTING` - 概念验证测试
6. `USER_FEEDBACK_COLLECTION` - 用户反馈收集
7. `POC_EVALUATION` - PoC效果评估
8. `PROJECT_FEASIBILITY_REPORT` - 项目可行性报告

**关联效能指标**：
- 指标55：需求累积流图（需求流转效率）
- 指标56：存量需求占比（需求积压情况）

### 2.2 建阶段（Build Phase）

**核心目标**：系统设计、代码开发、构建集成

#### 过程5：系统架构设计
**执行角色**：建设人员主导，研发和维护人员参与
**过程描述**：详细架构设计、技术选型确定
**细化事件序列**：
1. `ARCHITECTURE_DESIGN_START` - 架构设计开始
2. `TECH_STACK_SELECTION` - 技术栈选型
3. `MODULE_DESIGN` - 模块设计
4. `DATABASE_DESIGN` - 数据库设计
5. `INTERFACE_DESIGN` - 接口设计
6. `ARCHITECTURE_REVIEW` - 架构评审
7. `ARCHITECTURE_APPROVAL` - 架构方案确认

**关联效能指标**：
- 指标22：代码库语言分布（技术栈分布）
- 指标78：代码库统计（代码库状态）

#### 过程6：详细设计与UI/UX设计
**执行角色**：建设人员主导，用户参与确认
**过程描述**：详细设计文档、用户界面设计
**细化事件序列**：
1. `DETAIL_DESIGN_START` - 详细设计开始
2. `UI_MOCKUP_CREATION` - UI原型设计
3. `UX_FLOW_DESIGN` - 用户体验流程设计
4. `DATABASE_SCHEMA_DESIGN` - 数据库表结构设计
5. `API_SPECIFICATION` - API接口规范
6. `UI_REVIEW` - 界面设计评审
7. `DESIGN_DOCUMENT_COMPLETION` - 设计文档完成

**关联效能指标**：
- 指标3：工作项概览（工作项状态）
- 指标66：完成工作项（工作项完成情况）

#### 过程7：编码实现
**执行角色**：建设人员主导，管理和维护人员监督
**过程描述**：代码开发、单元测试、代码评审
**细化事件序列**：
1. `CODING_START` - 编码开始
2. `CODE_FRAMEWORK_SETUP` - 代码框架搭建
3. `CORE_FEATURE_DEVELOPMENT` - 核心功能开发
4. `CODE_COMMIT` - 代码提交
5. `UNIT_TEST_WRITING` - 单元测试编写
6. `CODE_REVIEW_REQUEST` - 代码评审申请
7. `CODE_REVIEW_FEEDBACK` - 代码评审反馈
8. `CODE_REVISION` - 代码修订
9. `MERGE_REQUEST` - 合并请求
10. `BUILD_EXECUTION` - 构建执行
11. `BUILD_FAILURE` - 构建失败
12. `BUG_FIX` - 问题修复
13. `BUILD_SUCCESS` - 构建成功
14. `BRANCH_MERGE` - 分支合并

**关联效能指标**：
- 指标20：代码提交趋势（开发活跃度）
- 指标21：提交按提交人趋势（个人贡献度）
- 指标81：代码提交按提交人排序（个人活跃度排名）
- 指标83：代码变更行趋势（代码变更规模）
- 指标92：代码变更行按人员排序（个人代码贡献）
- 指标95：代码变更概览（代码变更总览）
- 指标14：合并请求千行代码评论数趋势（代码评审质量）
- 指标15：合并请求评审趋势（评审活跃度）
- 指标16：新增合并请求按创建人排序（个人提交活跃度）
- 指标17：合并请求趋势（代码集成效率）
- 指标18：合并请求的合并分布（合并时间分布）
- 指标19：合并请求概览（合并请求状态）

#### 过程8：测试与质量保证
**执行角色**：建设人员主导，用户和维护人员参与
**过程描述**：集成测试、系统测试、质量评估
**细化事件序列**：
1. `TESTING_START` - 测试开始
2. `INTEGRATION_TEST` - 集成测试
3. `SYSTEM_TEST` - 系统测试
4. `PERFORMANCE_TEST` - 性能测试
5. `SECURITY_TEST` - 安全测试
6. `USER_ACCEPTANCE_TEST` - 用户验收测试
7. `BUG_DISCOVERY` - 缺陷发现
8. `BUG_REPORTING` - 缺陷报告
9. `BUG_FIXING` - 缺陷修复
10. `REGRESSION_TEST` - 回归测试
11. `QUALITY_ASSESSMENT` - 质量评估
12. `TEST_COMPLETION` - 测试完成

**关联效能指标**：
- 指标1：代码问题趋势（代码质量趋势）
- 指标11：存量问题类型趋势（问题类型分布）
- 指标12：存量问题按等级分布（问题严重程度）
- 指标13：代码问题概览（代码质量现状）
- 指标26：成功运行平均耗时按任务排名（任务执行效率）
- 指标27：失败率按任务排名（任务稳定性）
- 指标28：成功运行平均耗时按流水线排名（流水线效率）
- 指标29：失败率按流水线排名（流水线稳定性）

### 2.3 用阶段（Use Phase）

**核心目标**：系统部署、用户培训、价值实现

#### 过程9：部署准备
**执行角色**：用户人员主导，建设和维护人员支持
**过程描述**：部署环境准备、发布计划制定
**细化事件序列**：
1. `DEPLOYMENT_PLANNING` - 部署计划制定
2. `ENVIRONMENT_PREPARATION` - 环境准备
3. `DEPLOYMENT_PACKAGE_CREATION` - 部署包创建
4. `INFRASTRUCTURE_SETUP` - 基础设施搭建
5. `MONITORING_SETUP` - 监控系统配置
6. `BACKUP_STRATEGY_SETUP` - 备份策略配置
7. `DEPLOYMENT_READINESS_CHECK` - 部署就绪检查

**关联效能指标**：
- 指标33：流水线运行失败率趋势（构建质量趋势）
- 指标34：流水线成功运行平均耗时趋势（构建效率趋势）
- 指标40：运行概况（构建总体状况）

#### 过程10：软件部署与发布
**执行角色**：用户人员主导，建设人员技术支持
**过程描述**：生产环境部署、系统上线
**细化事件序列**：
1. `DEPLOYMENT_START` - 部署开始
2. `DATABASE_MIGRATION` - 数据库迁移
3. `APPLICATION_DEPLOYMENT` - 应用部署
4. `SERVICE_STARTUP` - 服务启动
5. `HEALTH_CHECK` - 健康检查
6. `SMOKE_TEST` - 冒烟测试
7. `DEPLOYMENT_SUCCESS` - 部署成功
8. `DEPLOYMENT_FAILURE` - 部署失败
9. `ROLLBACK_EXECUTION` - 回滚执行
10. `SYSTEM_ONLINE` - 系统上线

**关联效能指标**：
- 指标30：运行按流水线排名（部署频率）
- 指标31：运行按触发方式排名（部署触发方式）
- 指标32：运行按触发人排名（部署责任分布）
- 指标36：成功运行的时段分布（部署时间分布）
- 指标37：流水线失败恢复分布（故障恢复能力）
- 指标38：流水线运行分布（运行时间分布）
- 指标39：最近一次运行状态（当前部署状态）

#### 过程11：用户培训与推广
**执行角色**：用户人员主导，研发人员协助
**过程描述**：用户培训、系统推广、使用指导
**细化事件序列**：
1. `TRAINING_PLANNING` - 培训计划制定
2. `TRAINING_MATERIAL_PREPARATION` - 培训材料准备
3. `USER_TRAINING_SESSION` - 用户培训会议
4. `HANDS_ON_PRACTICE` - 实操练习
5. `USER_MANUAL_DISTRIBUTION` - 用户手册分发
6. `SYSTEM_PROMOTION` - 系统推广
7. `TRAINING_EFFECTIVENESS_EVALUATION` - 培训效果评估

**关联效能指标**：
- 指标47：交付需求按阶段停留累积（交付流程效率）
- 指标49：需求燃起图（需求交付进度）
- 指标51：需求交付效率概览（交付效率总览）

#### 过程12：用户反馈收集
**执行角色**：用户人员主导，管理人员监督
**过程描述**：用户行为分析、反馈收集、改进需求提出
**细化事件序列**：
1. `USER_BEHAVIOR_MONITORING` - 用户行为监控
2. `FEEDBACK_COLLECTION_START` - 反馈收集开始
3. `USER_SATISFACTION_SURVEY` - 用户满意度调查
4. `USAGE_DATA_ANALYSIS` - 使用数据分析
5. `IMPROVEMENT_SUGGESTION` - 改进建议收集
6. `FEEDBACK_ANALYSIS` - 反馈分析
7. `IMPROVEMENT_REQUEST_CREATION` - 改进需求创建
8. `FEEDBACK_REPORT_GENERATION` - 反馈报告生成

**关联效能指标**：
- 指标88：需求交付速率（交付速度分布）
- 指标90：需求交付分布（交付周期分布）
- 指标92：需求趋势（需求处理趋势）

### 2.4 管阶段（Management Phase）

**核心目标**：项目管理、团队协作、资源配置

#### 过程13：项目进度管理
**执行角色**：管理人员主导，贯穿全生命周期
**过程描述**：项目进度跟踪、里程碑管理、风险控制
**细化事件序列**：
1. `PROGRESS_TRACKING_START` - 进度跟踪开始
2. `MILESTONE_DEFINITION` - 里程碑定义
3. `TASK_ASSIGNMENT` - 任务分配
4. `PROGRESS_UPDATE` - 进度更新
5. `MILESTONE_REVIEW` - 里程碑评审
6. `RISK_IDENTIFICATION` - 风险识别
7. `RISK_MITIGATION` - 风险缓解
8. `SCHEDULE_ADJUSTMENT` - 计划调整
9. `PROGRESS_REPORT` - 进度报告

**关联效能指标**：
- 指标2：工作项变更（需求变更管理）
- 指标57：新增工作项概览（工作项增长）
- 指标65：工作项现状概览（工作项执行状态）
- 指标67：存量工作项（工作项积压）
- 指标72：存量工作项按项目排名（项目工作量对比）

#### 过程14：团队协作管理
**执行角色**：管理人员主导，所有角色参与
**过程描述**：团队沟通协调、工作分配、协作效率优化
**细化事件序列**：
1. `TEAM_MEETING` - 团队会议
2. `TASK_ALLOCATION` - 任务分配
3. `COLLABORATION_FACILITATION` - 协作促进
4. `COMMUNICATION_OPTIMIZATION` - 沟通优化
5. `CONFLICT_RESOLUTION` - 冲突解决
6. `TEAM_PERFORMANCE_REVIEW` - 团队绩效评审
7. `COLLABORATION_IMPROVEMENT` - 协作改进

**关联效能指标**：
- 指标42：工作项排名（个人工作量）
- 指标68：成员工作（个人工作状态）
- 指标71：兵力投入（团队投入分布）
- 指标72：团队概览（团队基本情况）

#### 过程15：资源配置管理
**执行角色**：管理人员主导，财务人员参与
**过程描述**：人力资源配置、预算管理、成本控制
**细化事件序列**：
1. `RESOURCE_PLANNING` - 资源规划
2. `BUDGET_ALLOCATION` - 预算分配
3. `COST_TRACKING` - 成本跟踪
4. `RESOURCE_OPTIMIZATION` - 资源优化
5. `BUDGET_REVIEW` - 预算评审
6. `COST_ANALYSIS` - 成本分析
7. `RESOURCE_REALLOCATION` - 资源重新分配

**关联效能指标**：
- 指标7：工时排名（个人工时投入）
- 指标8：工时投入排名（工时投入对比）
- 指标9：工时时间分布（工时登记规律）
- 指标10：工时按类别分布（工时类型分布）
- 指标43：迭代工时概览（迭代工时状况）
- 指标58：工时概览（工时总体状况）

### 2.5 维阶段（Maintenance Phase）

**核心目标**：系统运维、问题修复、持续改进

#### 过程16：问题诊断与修复
**执行角色**：维护人员主导，建设人员协助
**过程描述**：系统监控、问题诊断、缺陷修复
**细化事件序列**：
1. `MONITORING_ALERT` - 监控告警
2. `PROBLEM_IDENTIFICATION` - 问题识别
3. `PROBLEM_ANALYSIS` - 问题分析
4. `ROOT_CAUSE_ANALYSIS` - 根因分析
5. `FIX_DEVELOPMENT` - 修复开发
6. `FIX_TESTING` - 修复测试
7. `FIX_DEPLOYMENT` - 修复部署
8. `PROBLEM_RESOLUTION` - 问题解决
9. `RESOLUTION_VERIFICATION` - 解决方案验证
10. `MAINTENANCE_REPORT` - 维护报告

**关联效能指标**：
- 指标44：新增缺陷趋势（缺陷发现趋势）
- 指标46：修复缺陷按阶段停留累积（缺陷修复流程）
- 指标48：缺陷燃起图（缺陷修复进度）
- 指标52：新增缺陷概览（缺陷状态分布）
- 指标53：缺陷累积流图（缺陷流转效率）
- 指标61：缺陷修复效率概览（修复效率总览）
- 指标73：存量缺陷趋势（缺陷积压趋势）
- 指标75：存量缺陷按成员排名（个人缺陷负载）
- 指标76：存量缺陷占比（缺陷分布状况）
- 指标77：存量缺陷按项目排名（项目缺陷分布）
- 指标87：缺陷修复速率（修复速度分布）
- 指标89：缺陷修复分布（修复周期分布）
- 指标91：缺陷趋势（缺陷整体趋势）
- 指标93：缺陷现状概览（缺陷当前状态）

#### 过程17：性能优化与功能增强
**执行角色**：维护人员主导，研发和建设人员参与
**过程描述**：性能监控、系统优化、功能扩展
**细化事件序列**：
1. `PERFORMANCE_MONITORING` - 性能监控
2. `PERFORMANCE_ANALYSIS` - 性能分析
3. `OPTIMIZATION_PLANNING` - 优化规划
4. `FEATURE_ENHANCEMENT_REQUEST` - 功能增强请求
5. `OPTIMIZATION_IMPLEMENTATION` - 优化实现
6. `FEATURE_DEVELOPMENT` - 功能开发
7. `OPTIMIZATION_TESTING` - 优化测试
8. `FEATURE_TESTING` - 功能测试
9. `PERFORMANCE_VALIDATION` - 性能验证
10. `VERSION_RELEASE` - 版本发布
11. `ENHANCEMENT_VERIFICATION` - 增强验证

**关联效能指标**：
- 指标79：存量问题按引入人排序（问题责任分布）
- 指标80：存量问题按代码库趋势（代码库质量趋势）
- 指标84：代码提交时段分布（开发时间规律）
- 指标96：代码库概览（代码库整体状况）

#### 过程18：持续改进与迭代管理
**执行角色**：维护和管理人员主导，全员参与
**过程描述**：经验总结、流程改进、迭代规划
**细化事件序列**：
1. `ITERATION_PLANNING` - 迭代规划
2. `IMPROVEMENT_IDENTIFICATION` - 改进点识别
3. `PROCESS_OPTIMIZATION` - 流程优化
4. `BEST_PRACTICE_SHARING` - 最佳实践分享
5. `ITERATION_EXECUTION` - 迭代执行
6. `ITERATION_REVIEW` - 迭代回顾
7. `LESSONS_LEARNED` - 经验总结
8. `CONTINUOUS_IMPROVEMENT` - 持续改进

**关联效能指标**：
- 指标4：迭代燃尽图（迭代进度跟踪）
- 指标5：故事点燃尽图（故事点完成进度）
- 指标6：工时燃尽图（工时消耗进度）
- 指标50：工作项累积流图（工作项流转）
- 指标64：迭代进展（迭代状态总览）

## 3. 数据结构设计

### 3.1 项目数据结构

```typescript
interface Project {
  id: string;                    // 项目唯一标识
  name: string;                  // 项目名称
  status: ProjectStatus;         // 项目状态
  currentPhase: PhaseType;       // 当前阶段
  currentProcess: string;        // 当前过程
  startTime: Date;              // 项目开始时间
  endTime?: Date;               // 项目结束时间
  budget: BudgetInfo;           // 预算信息
  team: TeamMember[];           // 团队成员
  processes: ProcessInstance[]; // 过程实例
  events: EventInstance[];      // 事件实例
  metrics: MetricValue[];       // 效能指标值
  milestones: Milestone[];      // 里程碑
}

enum ProjectStatus {
  PLANNING = 'planning',
  RUNNING = 'running',
  PAUSED = 'paused',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled'
}

enum PhaseType {
  RESEARCH = 'research',    // 研阶段
  BUILD = 'build',         // 建阶段
  USE = 'use',             // 用阶段
  MANAGE = 'manage',       // 管阶段
  MAINTAIN = 'maintain'    // 维阶段
}
```

### 3.2 过程数据结构

```typescript
interface ProcessInstance {
  id: string;                   // 过程实例ID
  processId: string;           // 过程定义ID
  name: string;                // 过程名称
  phase: PhaseType;            // 所属阶段
  status: ProcessStatus;       // 过程状态
  assignedEmployee: string;    // 执行员工
  startTime?: Date;           // 开始时间
  endTime?: Date;             // 结束时间
  progress: number;           // 完成进度 (0-100)
  events: EventInstance[];    // 关联事件
  dependencies: string[];     // 依赖过程
  estimatedDuration: number;  // 预估工期（小时）
  actualDuration?: number;    // 实际工期（小时）
}

enum ProcessStatus {
  PENDING = 'pending',        // 等待中
  RUNNING = 'running',        // 执行中
  COMPLETED = 'completed',    // 已完成
  BLOCKED = 'blocked',        // 被阻塞
  FAILED = 'failed'          // 执行失败
}
```

### 3.3 事件数据结构

```typescript
interface EventInstance {
  id: string;                 // 事件实例ID
  eventId: string;           // 事件定义ID
  name: string;              // 事件名称
  processId: string;         // 所属过程ID
  type: EventType;           // 事件类型
  status: EventStatus;       // 事件状态
  triggeredBy: string;       // 触发者
  timestamp: Date;           // 发生时间
  duration: number;          // 持续时间（分钟）
  data: EventData;           // 事件数据
  impactedMetrics: string[]; // 影响的指标
}

enum EventType {
  MILESTONE = 'milestone',    // 里程碑事件
  TASK = 'task',             // 任务事件
  QUALITY = 'quality',       // 质量事件
  DEPLOYMENT = 'deployment', // 部署事件
  MAINTENANCE = 'maintenance' // 维护事件
}

enum EventStatus {
  SCHEDULED = 'scheduled',   // 已计划
  TRIGGERED = 'triggered',   // 已触发
  COMPLETED = 'completed',   // 已完成
  FAILED = 'failed'         // 执行失败
}

interface EventData {
  [key: string]: any;        // 事件相关数据
  codeLines?: number;        // 代码行数
  commitCount?: number;      // 提交次数
  bugCount?: number;         // 缺陷数量
  testCoverage?: number;     // 测试覆盖率
  buildTime?: number;        // 构建时间
  deploymentSuccess?: boolean; // 部署是否成功
}
```

### 3.4 效能指标数据结构

```typescript
interface MetricValue {
  id: string;                // 指标值ID
  metricId: string;          // 指标定义ID
  projectId: string;         // 项目ID
  name: string;              // 指标名称
  value: number | string;    // 指标值
  unit: string;              // 单位
  category: MetricCategory;  // 指标分类
  calculatedAt: Date;        // 计算时间
  trend: TrendType;          // 趋势
  threshold: ThresholdConfig; // 阈值配置
}

enum MetricCategory {
  PROJECT = 'project',       // 项目度量
  CODE = 'code',            // 代码度量
  PIPELINE = 'pipeline',    // 流水线度量
  QUALITY = 'quality',      // 质量保障
  WORKLOAD = 'workload'     // 工作负荷
}

enum TrendType {
  UP = 'up',                // 上升
  DOWN = 'down',            // 下降
  STABLE = 'stable'         // 稳定
}

interface ThresholdConfig {
  excellent: number;        // 优秀阈值
  good: number;            // 良好阈值
  warning: number;         // 警告阈值
  critical: number;        // 危险阈值
}
```

## 4. 事件与效能指标映射关系

### 4.1 研阶段事件-指标映射

| 事件 | 影响指标 | 计算逻辑 |
|------|----------|----------|
| REQUIREMENT_COLLECTION | 指标45: 新增需求趋势 | 每次需求收集时，新增需求数量+1 |
| REQUIREMENT_DOCUMENTATION | 指标54: 新增需求概览 | 统计各状态需求数量分布 |
| REQUIREMENT_APPROVAL | 指标94: 需求现状概览 | 更新需求执行状态统计 |
| TECH_FEASIBILITY_ANALYSIS | 指标69: 预估工时按成员排名 | 记录工时预估数据，按成员统计 |
| POC_DEVELOPMENT | 指标55: 需求累积流图 | 记录需求在各阶段的停留时间 |

### 4.2 建阶段事件-指标映射

| 事件 | 影响指标 | 计算逻辑 |
|------|----------|----------|
| CODE_COMMIT | 指标20: 代码提交趋势 | 每次提交时，提交次数+1，记录时间戳 |
| CODE_COMMIT | 指标21: 提交按提交人趋势 | 按提交人统计提交次数和趋势 |
| CODE_COMMIT | 指标81: 代码提交按提交人排序 | 统计各开发者提交次数排名 |
| CODE_COMMIT | 指标83: 代码变更行趋势 | 统计每次提交的代码行数变更 |
| MERGE_REQUEST | 指标14: 合并请求千行代码评论数趋势 | (评论总数/代码行数)*1000 |
| MERGE_REQUEST | 指标17: 合并请求趋势 | 统计合并请求的创建和处理趋势 |
| BUILD_EXECUTION | 指标26: 成功运行平均耗时按任务排名 | 统计各构建任务的平均执行时间 |
| BUILD_FAILURE | 指标27: 失败率按任务排名 | 失败次数/总执行次数 |
| BUG_DISCOVERY | 指标1: 代码问题趋势 | 统计缺陷发现数量和趋势 |

### 4.3 用阶段事件-指标映射

| 事件 | 影响指标 | 计算逻辑 |
|------|----------|----------|
| DEPLOYMENT_SUCCESS | 指标30: 运行按流水线排名 | 统计各流水线的部署频次 |
| DEPLOYMENT_FAILURE | 指标37: 流水线失败恢复分布 | 统计故障恢复时间分布 |
| SYSTEM_ONLINE | 指标39: 最近一次运行状态 | 记录最新的部署状态 |
| USER_FEEDBACK_COLLECTION | 指标88: 需求交付速率 | (完成需求数/时间周期) |
| IMPROVEMENT_REQUEST_CREATION | 指标92: 需求趋势 | 统计需求处理的整体趋势 |

### 4.4 管阶段事件-指标映射

| 事件 | 影响指标 | 计算逻辑 |
|------|----------|----------|
| TASK_ASSIGNMENT | 指标2: 工作项变更 | 统计工作项的变更次数和类型 |
| PROGRESS_UPDATE | 指标3: 工作项概览 | 更新工作项状态分布统计 |
| MILESTONE_REVIEW | 指标68: 项目进展 | 更新项目整体进展状态 |
| TEAM_MEETING | 指标42: 工作项排名 | 统计个人工作项完成情况排名 |
| COST_TRACKING | 指标7: 工时排名 | 统计个人工时投入排名 |

### 4.5 维阶段事件-指标映射

| 事件 | 影响指标 | 计算逻辑 |
|------|----------|----------|
| PROBLEM_IDENTIFICATION | 指标44: 新增缺陷趋势 | 每发现一个问题，缺陷数+1 |
| PROBLEM_RESOLUTION | 指标61: 缺陷修复效率概览 | 已修复缺陷数/总缺陷数 |
| FIX_DEPLOYMENT | 指标87: 缺陷修复速率 | 统计修复完成时间分布 |
| PERFORMANCE_OPTIMIZATION | 指标96: 代码库概览 | 更新代码库整体状况评估 |
| ITERATION_REVIEW | 指标4: 迭代燃尽图 | 更新迭代进度跟踪数据 |

## 5. 实时计算与推送机制

### 5.1 事件触发流程

1. **事件发生**：过程执行中触发具体事件
2. **事件记录**：将事件数据保存到数据库
3. **指标计算**：根据事件类型触发相关指标重新计算
4. **结果缓存**：将计算结果更新到指标缓存
5. **前端推送**：通过WebSocket推送最新指标数据给前端

### 5.2 指标计算引擎

```typescript
interface MetricCalculationEngine {
  // 注册指标计算规则
  registerMetric(metricId: string, calculator: MetricCalculator): void;
  
  // 事件触发指标计算
  onEventTriggered(event: EventInstance): Promise<void>;
  
  // 批量重新计算指标
  recalculateMetrics(projectId: string, metricIds: string[]): Promise<void>;
  
  // 获取指标当前值
  getMetricValue(projectId: string, metricId: string): Promise<MetricValue>;
}

interface MetricCalculator {
  // 计算指标值
  calculate(projectId: string, events: EventInstance[]): Promise<number | string>;
  
  // 获取依赖的事件类型
  getDependentEventTypes(): string[];
}
```

### 5.3 前端数据更新

```typescript
// 前端WebSocket监听
websocket.on('metric:updated', (data: {
  projectId: string;
  metricId: string;
  value: number | string;
  timestamp: Date;
}) => {
  // 更新看板界面的指标显示
  updateMetricDisplay(data.metricId, data.value);
  
  // 更新趋势图表
  updateTrendChart(data.metricId, data.value, data.timestamp);
  
  // 检查阈值告警
  checkThresholdAlert(data.metricId, data.value);
});

// 前端指标显示组件
interface MetricDisplayComponent {
  metricId: string;
  currentValue: number | string;
  trend: TrendType;
  history: MetricHistoryPoint[];
  threshold: ThresholdConfig;
}
```

## 6. 项目执行控制

### 6.1 项目线程管理

每个项目作为独立线程运行，维护自己的执行状态和数据：

```typescript
class ProjectExecutionThread {
  private projectId: string;
  private currentProcess: ProcessInstance | null;
  private eventQueue: EventInstance[];
  private isRunning: boolean;
  
  // 启动项目执行
  async start(): Promise<void>;
  
  // 暂停项目执行
  pause(): void;
  
  // 恢复项目执行
  resume(): void;
  
  // 执行下一个事件
  private async executeNextEvent(): Promise<void>;
  
  // 完成当前过程
  private async completeCurrentProcess(): Promise<void>;
  
  // 移动到下一个过程
  private async moveToNextProcess(): Promise<void>;
}
```

### 6.2 过程执行逻辑

1. **过程开始**：分配执行员工，设置过程状态为RUNNING
2. **事件执行**：按序列执行过程中的各个事件
3. **指标更新**：每个事件完成后立即计算相关指标
4. **进度更新**：更新过程和项目的整体进度
5. **过程完成**：所有事件执行完毕，过程状态设为COMPLETED
6. **阶段检查**：检查当前阶段是否完成，是否需要进入下一阶段

### 6.3 前端界面同步

- **左侧时序图**：实时显示当前执行的过程和状态
- **右上角员工信息**：显示当前过程的执行员工和状态
- **右下角事件列表**：显示当前过程正在执行的事件序列
- **看板界面**：实时更新所有效能指标的计算结果

## 7. 持久化存储方案

### 7.1 数据存储结构

```sql
-- 项目表
CREATE TABLE projects (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  status ENUM('planning','running','paused','completed','cancelled'),
  current_phase ENUM('research','build','use','manage','maintain'),
  current_process VARCHAR(50),
  start_time DATETIME,
  end_time DATETIME,
  budget_total DECIMAL(15,2),
  budget_used DECIMAL(15,2),
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 过程实例表
CREATE TABLE process_instances (
  id VARCHAR(50) PRIMARY KEY,
  project_id VARCHAR(50) NOT NULL,
  process_id VARCHAR(50) NOT NULL,
  name VARCHAR(200) NOT NULL,
  phase ENUM('research','build','use','manage','maintain'),
  status ENUM('pending','running','completed','blocked','failed'),
  assigned_employee VARCHAR(50),
  start_time DATETIME,
  end_time DATETIME,
  progress DECIMAL(5,2) DEFAULT 0,
  estimated_duration INT,
  actual_duration INT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- 事件实例表
CREATE TABLE event_instances (
  id VARCHAR(50) PRIMARY KEY,
  project_id VARCHAR(50) NOT NULL,
  process_id VARCHAR(50) NOT NULL,
  event_id VARCHAR(50) NOT NULL,
  name VARCHAR(200) NOT NULL,
  type ENUM('milestone','task','quality','deployment','maintenance'),
  status ENUM('scheduled','triggered','completed','failed'),
  triggered_by VARCHAR(50),
  timestamp DATETIME,
  duration INT,
  data JSON,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (project_id) REFERENCES projects(id),
  FOREIGN KEY (process_id) REFERENCES process_instances(id)
);

-- 效能指标值表
CREATE TABLE metric_values (
  id VARCHAR(50) PRIMARY KEY,
  project_id VARCHAR(50) NOT NULL,
  metric_id VARCHAR(50) NOT NULL,
  name VARCHAR(200) NOT NULL,
  value TEXT NOT NULL,
  unit VARCHAR(20),
  category ENUM('project','code','pipeline','quality','workload'),
  calculated_at DATETIME,
  trend ENUM('up','down','stable'),
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (project_id) REFERENCES projects(id)
);
```

### 7.2 数据恢复机制

系统启动时自动恢复所有项目的执行状态：

1. 加载所有未完成的项目
2. 恢复每个项目的当前过程和事件状态
3. 重新启动项目执行线程
4. 重新计算所有效能指标
5. 同步前端界面显示

## 8. 总结

本设计方案通过将软件开发过程按"研建用管维"五个阶段组织，每个阶段包含多个过程，每个过程细化为具体的事件序列，实现了对94个效能指标的全面覆盖和实时计算。

### 8.1 核心特点

1. **阶段化组织**：清晰的五阶段划分，符合软件开发生命周期
2. **事件驱动**：基于具体事件进行指标计算，确保数据准确性
3. **实时更新**：事件触发立即计算指标，前端实时展示
4. **数据持久化**：完整的数据存储和恢复机制
5. **多项目支持**：独立线程执行，支持多项目并发

### 8.2 实施价值

1. **全面度量**：覆盖94个效能指标，提供全方位的效能评估
2. **过程可视化**：实时展示项目执行过程和状态
3. **数据驱动决策**：基于量化数据进行项目管理决策
4. **持续改进**：通过效能指标识别改进机会
5. **标准化管理**：统一的过程定义和执行标准

通过这套设计方案，可以实现对软件开发全生命周期的精细化管理和效能度量，为项目成功交付提供有力支撑。
